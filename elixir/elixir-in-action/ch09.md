# 9장. 오류 영향 격리 (Isolating Error Effects)

- [9장. 오류 영향 격리 (Isolating Error Effects)](#9장-오류-영향-격리-isolating-error-effects)
  - [1. 오류 격리와 시스템 가용성](#1-오류-격리와-시스템-가용성)
  - [2. 감독 트리 (Supervision Trees)](#2-감독-트리-supervision-trees)
    - [느슨한 종속 관계의 분리](#느슨한-종속-관계의-분리)
    - [프로세스 탐색 (Rich Process Discovery)](#프로세스-탐색-rich-process-discovery)
    - [Via 튜플](#via-튜플)
    - [데이터베이스 워커 등록](#데이터베이스-워커-등록)
    - [데이터베이스 워커 감독](#데이터베이스-워커-감독)
    - [감독 트리 구성](#감독-트리-구성)
    - [OTP 준수 프로세스](#otp-준수-프로세스)
    - [프로세스 종료와 정리](#프로세스-종료와-정리)
    - [재시작 회피 전략](#재시작-회피-전략)
    - [재시작 전략의 종류](#재시작-전략의-종류)
  - [3. 동적 프로세스 시작 (Dynamic Supervision)](#3-동적-프로세스-시작-dynamic-supervision)
    - [To-do 서버 등록](#to-do-서버-등록)
    - [동적 감독자 (DynamicSupervisor)](#동적-감독자-dynamicsupervisor)
    - [To-do 서버 찾기](#to-do-서버-찾기)
    - [임시 재시작 전략 (Temporary)](#임시-재시작-전략-temporary)
  - [4. “충돌하게 내버려두기 (Let It Crash)” 철학](#4-충돌하게-내버려두기-let-it-crash-철학)
    - [절대 죽지 말아야 하는 프로세스](#절대-죽지-말아야-하는-프로세스)
    - [예상 가능한 오류 처리](#예상-가능한-오류-처리)
    - [상태(state) 보존](#상태state-보존)
  - [💡 핵심 요약 (Key Takeaways)](#-핵심-요약-key-takeaways)


---

## 1. 오류 격리와 시스템 가용성

* **목표:** 오류의 영향을 개별 워커 수준으로 제한하여 전체 시스템이 멈추지 않도록 한다.
* 예: **데이터베이스 오류**가 발생해도 **캐시 서비스**는 계속 동작해야 한다.
* **감독자(Supervisor)**는 실패한 프로세스만 재시작하여 나머지 부분을 보호한다.

---

## 2. 감독 트리 (Supervision Trees)

### 느슨한 종속 관계의 분리

![process](./images/09-01.png)
![process2](./images/09-02.png)

* 워커가 다른 워커 안에서 시작되면 **오류 전파 범위가 커진다.**
* 해결책: 모든 워커를 **감독자 아래에 직접 등록(one_for_one 전략)** 하여 개별 재시작 가능.
* 결과: 캐시와 데이터베이스 오류가 서로 격리된다.

### 프로세스 탐색 (Rich Process Discovery)

![process3](./images/09-03.png)

* 워커가 감독자 아래에서 시작되면 PID를 직접 추적하기 어렵다.
* **Registry**를 사용해 이름(키) ↔ PID를 매핑한다.
* **복잡한 키(예: `{:database_worker, 1}`)**를 사용할 수 있어 유연한 탐색이 가능하다.

### Via 튜플

* OTP 프로세스(GenServer 등)는 **`{:via, Module, data}`** 튜플을 사용해 외부 레지스트리에 등록 가능.
* 예:

  ```elixir
  {:via, Registry, {:my_registry, {EchoServer, id}}}
  ```
* PID 대신 이름 기반으로 프로세스 호출이 가능해진다.

### 데이터베이스 워커 등록

* `Todo.ProcessRegistry` 모듈을 추가해 `Registry` 프로세스를 감독한다.
* 워커 등록 예시:

  ```elixir
  Todo.ProcessRegistry.via_tuple({Todo.DatabaseWorker, id})
  ```
* **레지스트리 → 데이터베이스 → 캐시** 순으로 시작해야 한다. (의존 순서 중요)

### 데이터베이스 워커 감독

* `Todo.Database`를 **GenServer → Supervisor**로 변환한다.
* 여러 개의 `Todo.DatabaseWorker`를 자식으로 둔다.
* 각 워커는 `{Todo.DatabaseWorker, id}` 키로 등록된다.
* 감독 계층 예시:

  ```
  Todo.System
   ├─ Todo.ProcessRegistry
   ├─ Todo.Database (Supervisor)
   │   ├─ Worker 1
   │   ├─ Worker 2
   │   └─ Worker 3
   └─ Todo.Cache
  ```
* 개별 워커 충돌 시 해당 워커만 재시작되어 시스템 안정성 유지.

### 감독 트리 구성

![process4](./images/09-04.png)

* 감독자는 **서비스 관리자(service manager)** 역할을 한다.
* 하위 트리 단위로 종료할 수 있어 **유연한 종료와 재시작**이 가능하다.
* **에러 전파 규칙:**

  1. 워커가 죽으면 → 하위 수준에서 재시작
  2. 반복 실패 시 → 감독자 단위 재시작
  3. 불가 복구 시 → 상위 트리로 오류 전파

### OTP 준수 프로세스

* 감독자는 반드시 **OTP 규약(GenServer, Supervisor, Task, Agent 등)** 을 따르는 프로세스만 관리해야 함.
* `spawn_link`로 시작된 일반 프로세스는 OTP 규약을 따르지 않으므로 직접 감독하지 않는다.

### 프로세스 종료와 정리

* `:shutdown` 옵션으로 **우아한 종료(graceful termination)** 시간 지정 가능.

  * 정수: 대기 시간(ms)
  * `:infinity`: 무한 대기
  * `:brutal_kill`: 즉시 종료
* 기본값: 워커 5초, 감독자 무제한.

### 재시작 회피 전략

* `restart:` 옵션으로 재시작 방식을 조정한다.

  * `:temporary` → 종료 시 재시작하지 않음.
  * `:transient` → 비정상 종료 시에만 재시작.
  * 기본 → 항상 재시작.

### 재시작 전략의 종류

* `:one_for_one`: 실패한 프로세스만 재시작.
* `:one_for_all`: 한 프로세스가 죽으면 전체 자식 재시작.
* `:rest_for_one`: 충돌한 프로세스 이후의 자식만 재시작.
* **의존성이 강한 프로세스 그룹**에 적합한 전략을 선택해야 한다.

---

## 3. 동적 프로세스 시작 (Dynamic Supervision)

### To-do 서버 등록

* To-do 서버도 `via_tuple`로 이름 등록:

  ```elixir
  {:via, Registry, {Todo.ProcessRegistry, {Todo.Server, name}}}
  ```
* 데이터베이스 워커와 이름 충돌 방지.

### 동적 감독자 (DynamicSupervisor)

![process5](./images/09-05.png)

* `DynamicSupervisor`는 **실행 중 동적으로 자식 프로세스 생성** 가능.
* `Todo.Cache`를 동적 감독자로 변경:

  ```elixir
  DynamicSupervisor.start_child(__MODULE__, {Todo.Server, name})
  ```
* 여러 요청이 동시에 와도 안전하게 직렬화 처리된다.

### To-do 서버 찾기

* 서버가 없으면 새로 만들고, 이미 있으면 기존 PID 반환:

  ```elixir
  case start_child(name) do
    {:ok, pid} -> pid
    {:error, {:already_started, pid}} -> pid
  end
  ```
* 병렬 요청이 들어와도 **레이스 컨디션 없이 안전**하다.

### 임시 재시작 전략 (Temporary)

* To-do 서버는 다음과 같이 정의:

  ```elixir
  use GenServer, restart: :temporary
  ```
* 서버는 필요할 때 생성되고, 충돌 시 자동 재시작 불필요.
* 장점:

  * 충돌이 잦은 개별 서버가 전체 시스템에 영향을 주지 않음.
  * 종료 시 시스템 정리가 명확하고 안전함.

---

## 4. “충돌하게 내버려두기 (Let It Crash)” 철학

### 절대 죽지 말아야 하는 프로세스

* **에러 커널(Error Kernel):** 시스템 핵심 프로세스.
* 이들은 복원 불가능한 상태를 가지므로 단순하고 안정적으로 설계해야 함.
* 복잡한 로직은 별도의 워커로 분리하고, 핵심 프로세스는 최소 상태만 유지.
* 필요한 경우 `try/catch`를 이용해 부분 롤백 구현 가능.

### 예상 가능한 오류 처리

* 예측 가능한 오류는 직접 처리하고, 그 외에는 **충돌에 맡긴다.**

  ```elixir
  case File.read(file) do
    {:ok, contents} -> ...
    {:error, :enoent} -> nil
  end
  ```
* 예상치 못한 상황에서는 **프로세스가 충돌하도록 두고** 감독자가 복구하도록 한다.
* 예: 파일 쓰기 실패는 `File.write!/2`를 사용해 **즉시 예외 발생** → 빠른 실패(Fail Fast).

### 상태(state) 보존

* 프로세스 재시작 시 **상태는 초기화**된다.
* 필요한 경우 외부 저장소(예: 데이터베이스)에 상태를 **직렬화(persist)** 하여 복원 가능.
* 단, **오염된 상태를 저장**하면 재시작 시 무한 충돌 루프가 발생할 수 있으므로 주의.
* 상태는 모든 연산이 성공적으로 끝난 후에만 저장해야 한다:

  ```elixir
  def handle_cast({:add_entry, new_entry}, {name, todo_list}) do
    new_list = Todo.List.add_entry(todo_list, new_entry)
    Todo.Database.store(name, new_list)
    {:noreply, {name, new_list}}
  end
  ```

---

## 💡 핵심 요약 (Key Takeaways)

* **감독자(supervisor)**는 오류 격리의 핵심 — 고장 난 부분만 재시작.
* **Registry + via_tuple**로 유연한 이름 기반 프로세스 탐색 가능.
* **DynamicSupervisor**로 런타임 중 동적 프로세스 생성 관리.
* **Temporary/Transient 전략**으로 재시작 정책 세분화.
* **“Let it crash”** 철학은 단순하고 복원력 있는 코드를 만든다.
* **예상 가능한 오류만 처리하고**, 나머지는 감독자에게 맡긴다.
* **상태 보존은 신중히** — 잘못된 상태 저장은 무한 충돌을 유발할 수 있다.
