# Chapter 7. Building a Concurrent System in Elixir

- [Chapter 7. Building a Concurrent System in Elixir](#chapter-7-building-a-concurrent-system-in-elixir)
  - [1. Working with the Mix Project](#1-working-with-the-mix-project)
  - [2. Managing Multiple To-Do Lists](#2-managing-multiple-to-do-lists)
  - [3. Implementing a Cache](#3-implementing-a-cache)
  - [4. Writing Tests](#4-writing-tests)
  - [5. Analyzing Process Dependencies](#5-analyzing-process-dependencies)
  - [6. Persisting Data](#6-persisting-data)
    - [Encoding and Storing](#encoding-and-storing)
    - [Integrating Persistence](#integrating-persistence)
  - [7. Addressing Process Bottlenecks](#7-addressing-process-bottlenecks)
    - [1️⃣ Bypassing the Process](#1️⃣-bypassing-the-process)
    - [2️⃣ Handling Requests Concurrently](#2️⃣-handling-requests-concurrently)
    - [3️⃣ Limiting Concurrency with Pooling](#3️⃣-limiting-concurrency-with-pooling)
  - [8. Reasoning with Processes](#8-reasoning-with-processes)
  - [Key Takeaways](#key-takeaways)

## 1. Working with the Mix Project

* **Mix** is Elixir’s project management tool.

  * Create a new project: `$ mix new todo`.
  * Compile: `mix compile`; test: `mix test`.
  * Start interactive shell: `iex -S mix` (compiles first, then loads modules).
* **Conventions:**

  * One module per file, use snake_case filenames.
  * Place modules under a **common alias** (e.g., `Todo.Server`).
  * Folder structure mirrors module namespace: `lib/todo/server.ex`.

---

## 2. Managing Multiple To-Do Lists

* Two design options:

  1. **Single process** managing all lists — simpler but not scalable.
  2. **One process per list** — better scalability and concurrency.
* Use a **cache process** to manage and return server PIDs for each list.

  * Maintains a **map**: list name → server PID.
  * Starts servers on demand and stores them.

---

## 3. Implementing a Cache

* Implemented as a **GenServer**:

  * State: `%{ "list_name" => pid }`.
  * `handle_call/3` for synchronous requests:

    * Fetch PID if it exists; else start a new `Todo.Server`.
* Interface functions:

  ```elixir
  def start, do: GenServer.start(__MODULE__, nil)
  def server_process(cache_pid, name), do: GenServer.call(cache_pid, {:server_process, name})
  ```
* Example usage:

  ```elixir
  bobs_list = Todo.Cache.server_process(cache, "Bob")
  Todo.Server.add_entry(bobs_list, %{date: ~D[2023-12-19], title: "Dentist"})
  ```

---

## 4. Writing Tests

* Elixir uses **ExUnit**.

  * Test files end with `_test.exs` and live in `test/`.
  * Use `use ExUnit.Case` and `test "description" do ... end`.
  * `assert` macro checks expressions.
* Example:

  ```elixir
  assert bob_pid != Todo.Cache.server_process(cache, "alice")
  assert bob_pid == Todo.Cache.server_process(cache, "bob")
  ```
* Pattern matching can validate structure:

  ```elixir
  assert [%{title: "Dentist"}] = entries
  ```

---

## 5. Analyzing Process Dependencies

![process](./images/07-01.png)

* Architecture:

  * **Clients** → **Cache process (singleton)** → **Multiple server processes**.
* Potential bottleneck: the single cache can handle only one call at a time.
* Performance depends on request time:

  * 1 µs → 1M req/sec possible;
  * 100 ms → only ~10 req/sec.
* Each to-do server handles one list safely and serially — **no race conditions**.

---

## 6. Persisting Data

![process](./images/07-02.png)

### Encoding and Storing

* Use Erlang’s binary encoding:

  * `:erlang.term_to_binary(term)` and `:erlang.binary_to_term(binary)`.
* Introduce `Todo.Database` GenServer:

  * `store/2` (asynchronous cast) writes file.
  * `get/1` (synchronous call) reads file.
  * Files stored in `./persist` folder.

### Integrating Persistence

* Start the database from `Todo.Cache.init/1`.
* Modify `Todo.Server`:

  * Maintain `{list_name, todo_list}` state.
  * Store after each modification:

    ```elixir
    Todo.Database.store(name, new_list)
    ```
* Read list during initialization:

  ```elixir
  def handle_continue(:init, {name, nil}) do
    todo_list = Todo.Database.get(name) || Todo.List.new()
  end
  ```

---

## 7. Addressing Process Bottlenecks

### 1️⃣ Bypassing the Process

* If shared state or synchronization isn’t required, eliminate the GenServer.
* Perform file I/O directly, but watch for **unbounded concurrency**.

### 2️⃣ Handling Requests Concurrently

![process](./images/07-03.png)

* Keep central process but **spawn workers**:

  ```elixir
  spawn(fn -> File.write!(...) end)
  ```
* For calls:

  ```elixir
  spawn(fn -> GenServer.reply(caller, data) end)
  ```
* Improves concurrency but risks **I/O overload**.

### 3️⃣ Limiting Concurrency with Pooling

![process](./images/07-04.png)

* Maintain a **fixed number of worker processes** (e.g., 3).
* Distribute load in **round-robin** fashion.
* Controls concurrency, prevents system overload.

---

## 8. Reasoning with Processes

* A **server process** = a sequential program with a concurrent interface.
* Think of each process as a **microservice**:

  * `Todo.Server` → manages one list
  * `Todo.Cache` → maps names to servers
  * `Todo.Database` → handles persistence via worker pool
* **Calls vs. Casts:**

  * **Call:** synchronous, ensures consistency but blocks the caller.
  * **Cast:** asynchronous, boosts responsiveness but sacrifices reliability.
* **Back pressure:** Calls naturally limit client request rates.

---

## Key Takeaways

* **Mix projects** enforce conventions that simplify structure and testing.
* **GenServer abstraction** enables isolated, stateful concurrent processes.
* **Cache process** pattern elegantly manages dynamic worker lifecycles.
* **Calls** ensure correctness; **casts** improve throughput — choose wisely.
* **Persistence** introduces blocking I/O; use async workers or pooling.
* **Concurrency reasoning:** one process = sequential safety; many processes = scalability.
* The **actor model** in Elixir ensures no race conditions without explicit locking.

