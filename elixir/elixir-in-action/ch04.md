# 4장. 데이터 추상화 (Data Abstractions)

## 📑 목차

- [4장. 데이터 추상화 (Data Abstractions)](#4장-데이터-추상화-data-abstractions)
  - [📑 목차](#-목차)
  - [추상화의 기본 원칙](#추상화의-기본-원칙)
  - [모듈로 추상화하기](#모듈로-추상화하기)
  - [추상화의 구성(Composing Abstractions)](#추상화의-구성composing-abstractions)
  - [맵(Map)으로 데이터 구조화하기](#맵map으로-데이터-구조화하기)
  - [Struct로 추상화하기](#struct로-추상화하기)
    - [Struct와 Map 비교](#struct와-map-비교)
    - [Record(레코드)](#record레코드)
  - [데이터 투명성(Data Transparency)](#데이터-투명성data-transparency)
  - [계층적 데이터 다루기](#계층적-데이터-다루기)
    - [ID 자동 생성](#id-자동-생성)
    - [엔트리 업데이트](#엔트리-업데이트)
    - [불변 계층 구조 업데이트](#불변-계층-구조-업데이트)
    - [반복적 업데이트](#반복적-업데이트)
  - [프로토콜을 통한 다형성](#프로토콜을-통한-다형성)
    - [프로토콜 기본 개념](#프로토콜-기본-개념)
    - [프로토콜 구현하기](#프로토콜-구현하기)
    - [내장 프로토콜과 Collectable 예시](#내장-프로토콜과-collectable-예시)
  - [핵심 요약](#핵심-요약)

---

## 추상화의 기본 원칙

Elixir의 데이터 추상화는 다음 원칙을 따릅니다:

* **모듈(Module)** 은 특정 동작(behavior)을 추상화하는 단위이다.
* 함수는 보통 **추상화 인스턴스(데이터 구조)** 를 첫 번째 인자로 받는다.
* **수정 함수(modifier)** 는 수정된 버전의 추상화를 반환한다.
* **조회 함수(query)** 는 데이터를 읽기만 하고 다른 값을 반환한다.

이러한 설계 덕분에 Elixir의 모듈은 **조합 가능하고(pipe 연산자와 호환되는)** 함수형 추상화로 작동합니다.

---

## 모듈로 추상화하기

예시 — `MapSet` 사용:

```elixir
days = 
  MapSet.new()
  |> MapSet.put(:monday)
  |> MapSet.put(:tuesday)

MapSet.member?(days, :monday) # true
```

모든 함수가 첫 번째 인자로 `MapSet` 인스턴스를 받기 때문에
`|>` 파이프 연산자를 이용해 자연스럽게 연결할 수 있습니다.

---

## 추상화의 구성(Composing Abstractions)

복잡한 추상화는 더 단순한 추상화의 조합으로 구성됩니다.

예: 여러 값을 하나의 키에 저장하는 `MultiDict` 모듈

```elixir
defmodule MultiDict do
  def new(), do: %{}
  def add(dict, key, value),
    do: Map.update(dict, key, [value], &[value | &1])
  def get(dict, key),
    do: Map.get(dict, key, [])
end
```

이제 이를 기반으로 `TodoList`를 단순화할 수 있습니다:

```elixir
defmodule TodoList do
  def new(), do: MultiDict.new()
  def add_entry(todo_list, date, title),
    do: MultiDict.add(todo_list, date, title)
  def entries(todo_list, date),
    do: MultiDict.get(todo_list, date)
end
```

➡️ **관심사의 분리(Separation of Concerns)** — 각 모듈은 하나의 역할만 담당합니다.

---

## 맵(Map)으로 데이터 구조화하기

새로운 속성을 추가해야 할 때마다 함수 인자를 수정하면 유지보수가 어려워집니다.
따라서 엔트리의 속성을 하나의 구조로 묶는 것이 좋습니다.

```elixir
def add_entry(todo_list, entry) do
  MultiDict.add(todo_list, entry.date, entry)
end
```

이제 `entry`는 하나의 구조화된 데이터(Map)로 관리됩니다.

---

## Struct로 추상화하기

Struct는 **모듈에 연결된 미리 정의된 Map 형태**입니다.

```elixir
defmodule Fraction do
  defstruct a: nil, b: nil
end
```

* Struct는 항상 **모듈 내부에 정의**되며, **모듈당 하나**만 존재합니다.
* Struct의 **형태(shape)** 는 **컴파일 시점에 고정**되어, 타입 오류를 미리 방지합니다.
* 단순 Map보다 **안정성과 명확성**을 제공합니다.

---

### Struct와 Map 비교

Struct는 Map 기반이지만 다르게 동작합니다:

```elixir
one_half = %Fraction{a: 1, b: 2}

Enum.to_list(one_half)
# ** (Protocol.UndefinedError)
```

Struct는 기본적으로 Enumerable이 아니며, 명시적으로 정의해야 합니다.

```elixir
Enum.to_list(%{a: 1, b: 2}) 
# [a: 1, b: 2]
Map.to_list(one_half)
# [__struct__: Fraction, a: 1, b: 2]
```

**패턴 매칭**

```elixir
%Fraction{a: a, b: b} = %{a: 1, b: 2}   # MatchError
%{a: a, b: b} = %Fraction{a: 1, b: 2}   # OK
```

➡ Struct는 Map을 매칭할 수 있지만, 반대는 불가능합니다.

---

### Record(레코드)

* Tuple 기반으로 데이터를 이름으로 접근할 수 있게 한 구조.
* `defrecord`, `defrecordp` 매크로로 정의.
* Erlang 시절의 유산으로, **이전 라이브러리**에서는 여전히 사용됩니다.
* 현재는 대부분 Struct와 Map으로 대체됨.

---

## 데이터 투명성(Data Transparency)

Elixir에서는 데이터가 **항상 노출되고 읽을 수 있음**이 기본 철학입니다.

```elixir
todo_list =
  TodoList.new()
  |> TodoList.add_entry(%{date: ~D[2023-12-19], title: "Dentist"})
# %{~D[2023-12-19] => [%{date: ~D[2023-12-19], title: "Dentist"}]}
```

* 데이터 구조를 그대로 확인할 수 있어 **디버깅에 유용**합니다.
* 하지만 내부 구조에 **직접 의존하거나 수정하면 안 됩니다.**
  모듈이 제공하는 API 함수만 사용하는 것이 원칙입니다.

모든 복잡한 추상화(`MapSet`, `TodoList`)는 결국
**튜플, 리스트, 맵** 위에서 구축됩니다.

---

## 계층적 데이터 다루기

### ID 자동 생성

`TodoList`를 Struct로 변경하여 ID를 자동 생성하고 관리합니다.

```elixir
defmodule TodoList do
  defstruct next_id: 1, entries: %{}

  def new(), do: %TodoList{}

  def add_entry(todo_list, entry) do
    entry = Map.put(entry, :id, todo_list.next_id)
    new_entries = Map.put(todo_list.entries, todo_list.next_id, entry)
    %TodoList{todo_list | entries: new_entries, next_id: todo_list.next_id + 1}
  end

  def entries(todo_list, date) do
    todo_list.entries
    |> Map.values()
    |> Enum.filter(fn entry -> entry.date == date end)
  end
end
```

* `next_id`로 고유 ID 관리
* ID 기반 조회로 빠른 업데이트 가능
* `MultiDict` 불필요

---

### 엔트리 업데이트

```elixir
def update_entry(todo_list, entry_id, updater_fun) do
  case Map.fetch(todo_list.entries, entry_id) do
    :error -> todo_list
    {:ok, old_entry} ->
      new_entry = updater_fun.(old_entry)
      new_entries = Map.put(todo_list.entries, new_entry.id, new_entry)
      %TodoList{todo_list | entries: new_entries}
  end
end
```

* `Map.fetch/2` 로 안전한 조회
* 존재하지 않으면 원본 반환
* 항상 새로운 구조체를 반환 (불변성 유지)

---

### 불변 계층 구조 업데이트

Elixir는 **불변 데이터**를 원칙으로 합니다.
따라서 깊은 구조를 변경할 때는:

* 트리를 따라가며 변경할 부분을 새로 생성
* 부모 노드도 함께 새로 구성
* 메모리는 공유되어 효율적으로 처리됨

---

### 반복적 업데이트

여러 엔트리를 가진 TodoList 생성:

```elixir
def new(entries \\ []) do
  Enum.reduce(entries, %TodoList{}, &add_entry(&2, &1))
end
```

* `Enum.reduce/3` 로 리스트를 구조체로 축약
* 누산기(accumulator) 역할을 하는 `TodoList`를 갱신

---

## 프로토콜을 통한 다형성

### 프로토콜 기본 개념

Elixir의 **프로토콜(protocol)** 은 런타임에 입력 데이터 타입에 따라 실행 코드를 결정하는 **다형성(polymorphism)** 메커니즘입니다.

```elixir
defprotocol String.Chars do
  def to_string(term)
end
```

```elixir
String.Chars.to_string(1)          # "1"
String.Chars.to_string(:atom)      # "atom"
```

미구현 타입은 오류 발생:

```elixir
String.Chars.to_string(TodoList.new())
# ** (Protocol.UndefinedError)
```

보통은 직접 호출하지 않고,
`to_string/1` 같은 **Kernel 함수**가 내부적으로 프로토콜을 호출합니다.

---

### 프로토콜 구현하기

특정 타입에 대해 프로토콜을 구현하려면 `defimpl` 사용:

```elixir
defimpl String.Chars, for: Integer do
  def to_string(term), do: Integer.to_string(term)
end
```

* `for:` 뒤에 구현할 타입 지정 (예: `Integer`, `List`, `Map`, 사용자 정의 Struct 등)
* `Any`로 지정하면 **모든 타입의 기본 구현(fallback)** 이 됨.

사용자 정의 Struct에 대한 구현 예시:

```elixir
defimpl String.Chars, for: TodoList do
  def to_string(_), do: "#TodoList"
end
```

💡 **타입의 소스 코드를 수정하지 않아도**
별도 파일에 프로토콜 구현을 추가할 수 있습니다.

---

### 내장 프로토콜과 Collectable 예시

가장 중요한 프로토콜 중 하나는 **Enumerable**입니다.
이를 구현하면 `Enum`, `Stream` 모듈의 모든 기능을 사용할 수 있습니다.

또 다른 예 — `Collectable` 프로토콜:

```elixir
defimpl Collectable, for: TodoList do
  def into(original), do: {original, &into_callback/2}

  defp into_callback(todo_list, {:cont, entry}),
    do: TodoList.add_entry(todo_list, entry)

  defp into_callback(todo_list, :done), do: todo_list
  defp into_callback(_todo_list, :halt), do: :ok
end
```

* `into/1` 은 **수집기(appender)** 역할을 하는 함수를 반환
* `{:cont, entry}` → 새 항목 추가
* `:done` → 최종 반환
* `:halt` → 중단 시 처리

---

## 핵심 요약

* **모듈**은 데이터와 동작을 함께 추상화한다.
* **함수형 설계 원칙**(불변성, 조합성, 패턴 매칭)이 모든 추상화의 기초다.
* **Struct**는 Map보다 안전하고 컴파일 시점 검증이 가능하다.
* **데이터 투명성**은 디버깅에 유용하지만 내부 구조 의존은 금지된다.
* **프로토콜**을 구현하면 런타임 다형성을 쉽게 달성할 수 있다.
* **Collectable / Enumerable** 프로토콜은 추상화를 Elixir 표준 컬렉션처럼 사용할 수 있게 한다.

