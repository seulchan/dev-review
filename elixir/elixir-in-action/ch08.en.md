# Chapter 8 â€” Fault Tolerance Basics

- [Chapter 8 â€” Fault Tolerance Basics](#chapter-8--fault-tolerance-basics)
  - [1. Introduction to Fault Tolerance](#1-introduction-to-fault-tolerance)
  - [2. Run-time Errors in BEAM](#2-run-time-errors-in-beam)
    - [2.1 Error Types](#21-error-types)
    - [2.2 Handling Errors with `try/catch`](#22-handling-errors-with-trycatch)
  - [3. Errors in Concurrent Systems](#3-errors-in-concurrent-systems)
    - [3.1 Process Isolation](#31-process-isolation)
    - [3.2 Linking Processes](#32-linking-processes)
    - [3.3 Trapping Exits](#33-trapping-exits)
    - [3.4 Monitors](#34-monitors)
  - [4. Supervisors](#4-supervisors)
    - [4.1 Role of Supervisors](#41-role-of-supervisors)
    - [4.2 Starting a Supervisor](#42-starting-a-supervisor)
    - [4.3 Child Specification](#43-child-specification)
    - [4.4 Wrapping the Supervisor](#44-wrapping-the-supervisor)
    - [4.5 Callback-based Supervisors](#45-callback-based-supervisors)
    - [4.6 Linking All Processes](#46-linking-all-processes)
    - [4.7 Restart Frequency](#47-restart-frequency)
  - [ðŸ’¡ My Key Takeaways](#-my-key-takeaways)

## 1. Introduction to Fault Tolerance

* **Fault tolerance** allows systems to operate reliably despite run-time errors.
* Failures are inevitable: bugs, overloads, hardware, or network issues.
* A **resilient system** minimizes the impact of errors and recovers automatically.
* Goal: **Keep the system running**, even if parts fail (e.g., use cache when DB is down).
* **Error handling philosophy:**

  * Donâ€™t prevent all errors â€” **contain and recover** from them.
  * Itâ€™s better to let small parts fail than crash the whole system.
* **Concurrency** is the key tool in BEAM:

  * Processes are **isolated** and donâ€™t share memory.
  * A crash in one doesnâ€™t affect others.

---

## 2. Run-time Errors in BEAM

### 2.1 Error Types

* BEAM distinguishes **three run-time error types**:

  * `:error` â€” regular exceptions (e.g., division by zero).
  * `:exit` â€” deliberate process termination (`exit/1`).
  * `:throw` â€” nonlocal return (used rarely).
* Convention:

  * Functions ending with **!** (e.g., `File.open!`) **raise errors**.
  * Non-! versions return tagged tuples (`{:ok, result}` / `{:error, reason}`).

### 2.2 Handling Errors with `try/catch`

* Basic form:

  ```elixir
  try do
    ...
  catch type, value ->
    ...
  end
  ```
* `type` can be `:error`, `:exit`, or `:throw`.
* The caught `value` is the error message or thrown term.
* `after` block always executes (for cleanup).
* Pattern matching allows selective handling:

  ```elixir
  catch :throw, {:result, x} -> x
  ```
* **Return value:** result of last expression in `do` or matching `catch`.
* **No tail-call optimization** in functions ending with `try` â€” not last operation.
* In Elixir, itâ€™s often **better to let the process crash** and restart it than to rescue every error.

---

## 3. Errors in Concurrent Systems

![isolating](./images/08-01.png)

### 3.1 Process Isolation

* Each BEAM process runs independently â€” a crash in one doesnâ€™t corrupt others.
* Example: Parent crash doesnâ€™t stop child process.
* Isolation prevents memory corruption between processes.

### 3.2 Linking Processes

![linking](./images/08-02.png)

* **Links** connect processes to detect crashes.
* Created via `Process.link/1` or `spawn_link/1`.
* If one process crashes abnormally, linked processes receive an **exit signal** and may crash too.
* One link connects **exactly two processes**, bidirectionally.

### 3.3 Trapping Exits

* Enables a process to **receive crash messages** instead of crashing itself.
* Activated with:

  ```elixir
  Process.flag(:trap_exit, true)
  ```
* Exit messages have the form:

  ```elixir
  {:EXIT, from_pid, exit_reason}
  ```
* Useful for recovery logic or logging.

### 3.4 Monitors

* **Monitors** are **unidirectional** and **non-fatal**.
* Set up with:

  ```elixir
  ref = Process.monitor(pid)
  ```
* On crash, a message arrives:

  ```elixir
  {:DOWN, ref, :process, pid, reason}
  ```
* Used internally in `GenServer.call` to detect server crashes.

---

## 4. Supervisors

![processes](./images/08-03.png)

### 4.1 Role of Supervisors

* **Supervisors manage worker processes**, restarting them if they fail.
* Workers do the actual work; supervisors monitor and recover them.
* Started via:

  ```elixir
  Supervisor.start_link(children, strategy: :one_for_one)
  ```
* **Restart strategy:** `:one_for_one` â€” restart only the failed child.

### 4.2 Starting a Supervisor

* Example:

  ```elixir
  Supervisor.start_link([Todo.Cache], strategy: :one_for_one)
  ```
* Each child module (like `Todo.Cache`) must implement `start_link/1`.
* Registered process names are essential because **PIDs change after restarts**.

### 4.3 Child Specification

* Defines **how to start and identify** a child process:

  ```elixir
  %{
    id: Todo.Cache,
    start: {Todo.Cache, :start_link, [nil]}
  }
  ```
* Supervisor uses `apply(module, function, args)` to start children.
* Default `child_spec/1` is auto-generated for modules using `GenServer`.

### 4.4 Wrapping the Supervisor

* Encapsulate Supervisor logic in a module:

  ```elixir
  defmodule Todo.System do
    def start_link do
      Supervisor.start_link([Todo.Cache], strategy: :one_for_one)
    end
  end
  ```

### 4.5 Callback-based Supervisors

* Alternative structure with `use Supervisor`:

  ```elixir
  def init(_) do
    Supervisor.init([Todo.Cache], strategy: :one_for_one)
  end
  ```
* Allows pre-start initialization and easier hot-code updates.

### 4.6 Linking All Processes

![link-processes](./images/08-04.png)

* All dependent processes (`Cache`, `Servers`, `DB`) should be **linked**.
* If one fails â†’ linked chain terminates â†’ supervisor restarts the entire group.
* Use `start_link` everywhere for proper linkage:

  ```elixir
  def start_link(...) do
    GenServer.start_link(...)
  end
  ```
* This ensures **self-healing** and avoids zombie processes.

### 4.7 Restart Frequency

* Supervisor stops restarting if restarts exceed the limit.

  * Default: **3 restarts / 5 seconds**
  * Configurable via `:max_restarts` and `:max_seconds`.
* Prevents infinite restart loops â€” signals deeper structural issues.

---

## ðŸ’¡ My Key Takeaways

* Fault tolerance â‰  error prevention â€” itâ€™s about **containment and recovery**.
* **Process isolation** is BEAMâ€™s foundation: errors stay local.
* **Let it crash** philosophy: restarting is cleaner than rescuing bad state.
* Use **links** for mutual dependency, **monitors** for one-way observation.
* **Supervisors** automatically restart children using defined strategies.
* Always use `start_link` for supervised or interdependent processes.
* Manage **restart frequency** to prevent runaway failure loops.
