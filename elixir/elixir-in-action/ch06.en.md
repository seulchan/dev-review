# Chapter 6. Generic Server Processes
- [Chapter 6. Generic Server Processes](#chapter-6-generic-server-processes)
  - [1. Introduction to OTP Framework](#1-introduction-to-otp-framework)
  - [2. Building a Generic Server Process](#2-building-a-generic-server-process)
    - [Plugging in with Modules](#plugging-in-with-modules)
    - [Implementing Generic Code](#implementing-generic-code)
    - [Using the Generic Abstraction](#using-the-generic-abstraction)
    - [Supporting Asynchronous Requests](#supporting-asynchronous-requests)
  - [3. Using GenServer](#3-using-genserver)
    - [OTP Behaviours](#otp-behaviours)
    - [Plugging into GenServer](#plugging-into-genserver)
    - [Handling Requests](#handling-requests)
    - [Handling Plain Messages](#handling-plain-messages)
    - [Other GenServer Features](#other-genserver-features)
      - [Compile-Time Checking](#compile-time-checking)
      - [Name Registration](#name-registration)
      - [Stopping the Server](#stopping-the-server)
    - [Process Life Cycle](#process-life-cycle)
    - [OTP-Compliant Processes](#otp-compliant-processes)
  - [Key Takeaways](#key-takeaways)

## 1. Introduction to OTP Framework

* **OTP (Open Telecom Platform)** is a set of patterns and abstractions for building robust systems, not limited to telecoms.
* Provides tools for **fault tolerance**, **error recovery**, **logging**, and **process supervision**.
* Core concept: **generic server processes** that handle messages and maintain state across requests.

---

## 2. Building a Generic Server Process

### Plugging in with Modules

* Generic code can be reused by different implementations using **callback modules**.
* The **callback module** provides specific logic (e.g., `init/0`, `handle_call/2`) while the generic process handles message routing.
* Module atoms (e.g., `some_module = IO`) can be stored and dynamically invoked for callbacks.

### Implementing Generic Code

* **`ServerProcess.start/1`** spawns a new process that runs `loop/2`.
* The **callback’s `init/0`** initializes state.
* The **loop**:

  ```elixir
  receive do
    {request, caller} ->
      {response, new_state} = callback_module.handle_call(request, current_state)
      send(caller, {:response, response})
      loop(callback_module, new_state)
  end
  ```
* Generic loop maintains **state** and delegates logic to callback functions.

### Using the Generic Abstraction

* Example: **KeyValueStore** implements `init/0` and `handle_call/2`.
* The `ServerProcess` handles the concurrency; `KeyValueStore` only handles logic.
* Helper “interface functions” (`start`, `put`, `get`) abstract away the process management for the client.

### Supporting Asynchronous Requests

* Introduced **two request types**:

  * `call`: synchronous (client waits for response).
  * `cast`: asynchronous (client does not wait).
* Message formats:

  ```elixir
  {:call, request, caller}
  {:cast, request}
  ```
* Callback `handle_cast/2` handles fire-and-forget updates.

---

## 3. Using GenServer

### OTP Behaviours

* **Behaviour:** generic pattern module that requires specific callbacks (e.g., `GenServer`, `Supervisor`).
* **Common behaviours:**

  * `gen_server` – stateful server processes
  * `application` – component management
  * `gen_event` – event handling
  * `gen_statem` – finite-state machines
* In Elixir, these are wrapped as **modules** (`GenServer`, `Supervisor`, `Application`).

### Plugging into GenServer

* Use `use GenServer` to inject default callback templates.
* Provides pre-defined functions (`handle_call/3`, `handle_cast/2`, `init/1`, etc.).
* Start with:

  ```elixir
  GenServer.start(KeyValueStore, nil)
  ```

### Handling Requests

* Required callbacks:

  * `init(_) -> {:ok, initial_state}`
  * `handle_cast(request, state) -> {:noreply, new_state}`
  * `handle_call(request, from, state) -> {:reply, response, new_state}`
* Interface functions:

  ```elixir
  def start, do: GenServer.start(KeyValueStore, nil)
  def put(pid, k, v), do: GenServer.cast(pid, {:put, k, v})
  def get(pid, k), do: GenServer.call(pid, {:get, k})
  ```
* **Differences vs ServerProcess:**

  * `GenServer.start/2` waits for `init/1` to complete.
  * `GenServer.call/2` has a default **5s timeout**.
  * Automatically handles crash propagation.

### Handling Plain Messages

* `GenServer` handles internal messages tagged as `:$gen_call` or `:$gen_cast`.
* Other messages (e.g., from `:timer.send_interval/2`) are handled by:

  ```elixir
  def handle_info(:cleanup, state) do
    IO.puts "performing cleanup..."
    {:noreply, state}
  end
  ```
* Enables periodic or custom message handling outside `call`/`cast`.

---

### Other GenServer Features

#### Compile-Time Checking

* Use `@impl GenServer` for callback definitions to catch signature errors early:

  ```elixir
  @impl GenServer
  def handle_call(request, from, state), do: {:reply, request, state}
  ```

#### Name Registration

* Processes can be **registered by name** for global access:

  ```elixir
  GenServer.start(KeyValueStore, nil, name: :KeyValueStore)
  GenServer.call(:KeyValueStore, {:get, :key})
  ```
* `__MODULE__` can replace explicit names for easier refactoring.

#### Stopping the Server

* Possible return values:

  * `{:ok, state}` → normal start
  * `{:stop, reason}` → initialization error
  * `:ignore` → intentionally skip start
* From callbacks:

  * `{:stop, reason, state}` or
  * `{:stop, reason, reply, state}`
* Also stoppable via `GenServer.stop/3`.
* Before termination, `terminate/2` is called for cleanup.

---

### Process Life Cycle

![life](./images/06-01.png)

* `GenServer.start` creates the process → invokes `init/1`.
* **Clients** use `GenServer.call` / `cast` → server receives messages.
* **Callbacks** (`handle_*`) run in the **server process**, not the client.
* **State** evolves through callbacks (`init → handle_* → loop`).

---

### OTP-Compliant Processes

* Avoid plain `spawn` in production.
* OTP-compliant processes integrate with supervision, logging, and fault tolerance.
* **Modules:**

  * `GenServer` → general servers
  * `Supervisor` → fault-tolerant supervision
  * `Task` → one-off asynchronous jobs
  * `Agent` → simplified state management

---

## Key Takeaways

* **Generic servers** encapsulate message handling and state management; logic is delegated to callbacks.
* **GenServer** provides standardized, fault-tolerant abstractions for server processes.
* **Calls** are synchronous; **casts** are asynchronous.
* Always mark callbacks with `@impl` for safety and maintainability.
* Register servers by name to avoid tracking PIDs manually.
* Use `handle_info/2` for non-GenServer messages like periodic tasks.
* OTP-compliant processes are essential for reliability in production Elixir systems.
