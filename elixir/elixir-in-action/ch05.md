# 5장. 동시성 기본 원리 (Concurrency Primitives)

## 목차

1. [BEAM의 동시성 개념](#beam의-동시성-개념)
2. [프로세스 다루기](#프로세스-다루기)
   * 프로세스 생성
   * 메시지 전달 (Message Passing)
3. [상태를 가진 서버 프로세스](#상태를-가진-서버-프로세스)

   * 서버 프로세스의 구조
   * 순차적 실행과 프로세스 풀
   * 상태 유지와 변경 가능한 상태
   * 계산기 서버 구현
   * 루프 리팩토링
   * 복잡한 상태(TodoServer 예시)
   * 등록된 프로세스 (Registered Process)
4. [런타임 동작 이해](#런타임-동작-이해)

   * 프로세스의 순차성
   * 무한 메일박스 문제
   * 메모리 공유 없는 동시성
   * 스케줄러의 작동 원리
5. [핵심 요약](#핵심-요약)

---

## BEAM의 동시성 개념

* **Erlang/Elixir의 핵심 목표**는 “항상 실행되고, 항상 응답 가능한 시스템”을 만드는 것.
* 고가용성(High Availability)을 위해 해결해야 할 과제:

  * **내결함성(Fault tolerance)** → 오류를 최소화하고, 격리 및 복구
  * **확장성(Scalability)** → 코드 수정 없이 하드웨어 자원 확장
  * **분산성(Distribution)** → 여러 노드 간 협력 및 장애 대응

### BEAM의 프로세스
![beam](./images/05-01.png)
* **BEAM 프로세스**는 OS 프로세스나 스레드와 다름 — VM 내부의 경량 실행 단위
* **스케줄러(Scheduler)**: CPU 코어 수만큼 생성되어 여러 프로세스를 관리
* **가벼운 프로세스**: 생성 시간은 수 μs, 메모리 사용량은 약 2KB
* **완전한 격리**: 메모리 공유 없음, 한 프로세스의 오류가 다른 프로세스에 영향 X
* **복구 메커니즘**: BEAM은 프로세스 크래시를 감지하고 자동 재시작 가능

➡ 결과적으로 BEAM 시스템은 **수백만 개의 프로세스**를 동시에 실행할 수 있음.

---

## 프로세스 다루기

### 프로세스 생성

```elixir
spawn(fn ->
  IO.puts("새로운 프로세스에서 실행 중")
end)
# #PID<0.48.0>
```

* `spawn/1`은 새로운 프로세스를 생성하고, 그 **PID**를 반환한다.
* PID는 프로세스 간 통신의 식별자 역할을 한다.
* 부모 프로세스는 즉시 반환되어, 자식 프로세스는 **동시 실행**된다.

### 예: 병렬 쿼리 실행

```elixir
run_query = fn query ->
  Process.sleep(2000)
  "#{query} result"
end

Enum.each(1..5, fn i ->
  spawn(fn -> IO.puts(run_query.("query #{i}")) end)
end)
```

➡ 5개의 쿼리가 **2초 내에 병렬 실행**됨 (순차 실행 시 10초 필요).

---

### 메시지 전달 (Message Passing)

![02](./images/05-02.png)

* 프로세스 간에는 **공유 메모리 없이 메시지**로만 통신한다.
* `send(pid, message)`로 메시지를 보낼 수 있으며,
  수신자는 `receive` 구문으로 메시지를 처리한다.

```elixir
send(self(), {:message, 1})
receive do
  {:message, id} ->
    IO.puts("메시지 수신: #{id}")
end
```

**특징:**

1. **FIFO 메일박스** — 순서대로 처리됨.
2. **깊은 복사(Deep copy)** — 메시지는 프로세스 간 메모리 공유 없이 복사됨.
3. **패턴 매칭 기반 처리** — 일치하는 메시지만 소비되고, 나머지는 대기함.

#### `after` 절로 타임아웃 처리

```elixir
receive do
  msg -> IO.inspect(msg)
after
  5000 -> IO.puts("5초 안에 메시지 없음")
end
```

#### 동기식 메시징

```elixir
# 송신자
send(pid, {self(), :ping})
receive do {:pong, msg} -> msg end

# 수신자
receive do
  {caller, :ping} -> send(caller, {:pong, "ok"})
end
```

➡ 호출자는 응답을 받을 때까지 대기 (동기식 통신).

---

## 상태를 가진 서버 프로세스

### 서버 프로세스의 개념

* **오랫동안 실행되는 프로세스**로, 메시지를 기다리고 응답하는 구조.
* **꼬리 재귀(tail recursion)** 로 무한 루프를 구현:

  ```elixir
  defp loop do
    receive do
      msg -> handle(msg)
    end
    loop()
  end
  ```

### 데이터베이스 서버 예시

```elixir
defmodule DatabaseServer do
  def start, do: spawn(&loop/0)

  defp loop do
    receive do
      {:run_query, caller, query} ->
        result = run_query(query)
        send(caller, {:query_result, result})
    end
    loop()
  end
end
```

➡ `loop/0`은 서버의 “핵심 루프”.
메시지(`:run_query`)를 수신 → 처리 → 결과를 발신자에게 전송.

---

### 클라이언트 인터페이스

```elixir
def run_async(pid, query), do: send(pid, {:run_query, self(), query})

def get_result do
  receive do
    {:query_result, result} -> result
  after
    5000 -> {:error, :timeout}
  end
end
```

➡ 클라이언트는 메시지 포맷을 알 필요 없이 단순 함수 호출로 서버 사용 가능.

---

### 순차적 실행과 프로세스 풀

* 서버 프로세스는 **동시에 한 개의 메시지만 처리**한다.
* 여러 요청을 병렬 처리하려면 **프로세스 풀(pool)** 사용.

```elixir
pool = Enum.map(1..100, fn _ -> DatabaseServer.start() end)
pid = Enum.at(pool, :rand.uniform(100) - 1)
DatabaseServer.run_async(pid, "query")
```

➡ 100개의 서버 프로세스가 각각 독립적으로 요청을 처리.

---

### 상태 유지 (Stateful Process)

서버 프로세스는 내부에 **상태(state)** 를 유지할 수 있다.

```elixir
def start do
  spawn(fn ->
    connection = :rand.uniform(1000)
    loop(connection)
  end)
end

defp loop(connection) do
  receive do
    {:run_query, from, query} ->
      result = run_query(connection, query)
      send(from, {:query_result, result})
  end
  loop(connection)
end
```

➡ 매 루프마다 **상태를 인자로 전달**하여 지속성을 유지.

---

### 변경 가능한 상태 (Mutable-like State)

Elixir는 불변성을 유지하지만, 루프를 통해 **상태 갱신을 시뮬레이션**한다.

```elixir
defp loop(state) do
  new_state =
    receive do
      {:add, x} -> state + x
      {:sub, x} -> state - x
      {:value, caller} -> send(caller, {:response, state}); state
    end
  loop(new_state)
end
```

➡ 내부적으로는 불변이지만, 외부에서는 “변경 가능한 상태”처럼 보임.

---

### 계산기 서버 예시

```elixir
defmodule Calculator do
  def start, do: spawn(fn -> loop(0) end)

  defp loop(value) do
    new_value =
      receive do
        {:add, x} -> value + x
        {:sub, x} -> value - x
        {:value, caller} -> send(caller, {:response, value}); value
      end
    loop(new_value)
  end

  def add(pid, x), do: send(pid, {:add, x})
  def value(pid) do
    send(pid, {:value, self()})
    receive do {:response, v} -> v end
  end
end
```

---

### 루프 리팩토링

메시지 처리 코드를 별도 함수로 분리:

```elixir
defp loop(state) do
  receive do
    msg -> loop(process_message(state, msg))
  end
end

defp process_message(state, {:add, x}), do: state + x
defp process_message(state, {:value, caller}) do
  send(caller, {:response, state}); state
end
```

➡ 유지보수성과 가독성 향상.

---

### 복잡한 상태: TodoServer

```elixir
defmodule TodoServer do
  def start, do: spawn(fn -> loop(TodoList.new()) end)

  def add_entry(pid, entry),
    do: send(pid, {:add_entry, entry})

  def entries(pid, date) do
    send(pid, {:entries, self(), date})
    receive do {:todo_entries, entries} -> entries end
  end

  defp loop(todo_list) do
    receive do
      {:add_entry, entry} -> loop(TodoList.add_entry(todo_list, entry))
      {:entries, caller, date} ->
        send(caller, {:todo_entries, TodoList.entries(todo_list, date)})
        loop(todo_list)
    end
  end
end
```

➡

* **TodoList**: 순수 함수형 데이터 구조
* **TodoServer**: 상태를 유지하고 병렬적으로 처리하는 프로세스

---

### 등록된 프로세스 (Registered Process)

PID 대신 **이름(Atom)** 으로 프로세스를 식별 가능:

```elixir
def start do
  spawn(fn ->
    Process.register(self(), :todo_server)
    loop(TodoList.new())
  end)
end

def add_entry(entry), do: send(:todo_server, {:add_entry, entry})
```

**제약 조건:**

* 이름은 **원자(atom)** 여야 함
* 한 프로세스는 하나의 이름만 가질 수 있음
* 동일 이름의 중복 등록 불가

➡ PID를 전달할 필요 없이 단일 인스턴스 서버 구현 가능.

---

## 런타임 동작 이해

### 프로세스의 순차성

* 프로세스는 내부적으로 **순차적**으로 실행됨.
* 다수의 프로세스가 하나의 서버에 메시지를 보내면 **병목 현상** 발생 가능.
* 해결책:

  1. 메시지 처리 속도 최적화
  2. 서버를 여러 개로 분할 (프로세스 풀)

---

### 무한 메일박스 문제

* 프로세스의 메일박스는 메모리 한도 내에서 **무한히 커질 수 있음**.
* 메시지를 처리하지 않으면 **메모리 누수** 발생.
* 해결책: 항상 **catch-all 절** 추가.

```elixir
receive do
  {:msg, m} -> handle(m)
  other -> IO.puts("Unknown message: #{inspect other}")
end
```

---

### 메모리 공유 없는 동시성 (Shared-nothing)

* 각 프로세스는 독립된 **힙 메모리(약 2KB)** 를 가짐.
* 메시지나 클로저 변수 전달 시 **깊은 복사(Deep copy)** 수행.
* 장점:

  * 완전한 격리 → 오류 전파 방지
  * **프로세스별 GC** → 시스템 전체 중단 없음

---

### 스케줄러의 작동 원리

![03](./images/05-03.png)

* BEAM은 **m:n 스레딩 모델**을 사용 (많은 프로세스를 적은 스레드에 매핑).
* 각 스케줄러는 약 **2000 함수 호출 단위**로 프로세스 교체 (선점형 스케줄링).
* 스케줄러 수는 Erlang 플래그로 조정 가능:

  ```bash
  iex --erl "+S 1"
  ```
* 단일 스케줄러 환경에서도 **짧은 타임슬라이스 교체** 덕분에 시스템은 여전히 응답성을 유지.

---

## 핵심 요약

* **BEAM 프로세스**는 매우 가볍고 완전 격리된 동시 실행 단위이다.
* **메시지 전달(Message Passing)** 로만 통신하며, 메모리 공유는 없다.
* **서버 프로세스**는 상태를 유지하며 요청을 순차적으로 처리한다.
* **불변 데이터 구조**와 **프로세스 상태**를 조합하면 안정적인 병렬 시스템 구축 가능.
* **메일박스 관리**와 **병목 방지**는 성능 유지의 핵심이다.
* **BEAM 스케줄러**는 짧은 선점 교체로 시스템 전체 응답성을 보장한다.
