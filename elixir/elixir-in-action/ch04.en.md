# Chapter 4. Data Abstractions

## 📑 Table of Contents

- [Chapter 4. Data Abstractions](#chapter-4-data-abstractions)
  - [📑 Table of Contents](#-table-of-contents)
  - [Principles of Abstraction](#principles-of-abstraction)
  - [Abstracting with Modules](#abstracting-with-modules)
  - [Composing Abstractions](#composing-abstractions)
  - [Structuring Data with Maps](#structuring-data-with-maps)
  - [Abstracting with Structs](#abstracting-with-structs)
    - [Structs vs. Maps](#structs-vs-maps)
    - [Records](#records)
  - [Data Transparency](#data-transparency)
  - [Working with Hierarchical Data](#working-with-hierarchical-data)
    - [Generating IDs](#generating-ids)
    - [Updating Entries](#updating-entries)
    - [Immutable Hierarchical Updates](#immutable-hierarchical-updates)
    - [Iterative Updates](#iterative-updates)
  - [Polymorphism with Protocols](#polymorphism-with-protocols)
    - [Protocol Basics](#protocol-basics)
    - [Implementing a Protocol](#implementing-a-protocol)
    - [Built-in Protocols](#built-in-protocols)
    - [Collectable TodoList Example](#collectable-todolist-example)
  - [Key Takeaways](#key-takeaways)

---

## Principles of Abstraction

Elixir’s abstraction design follows these conventions:

* A **module** defines a self-contained behavior abstraction.
* Functions take an **instance** of that abstraction as their **first argument**.
* **Modifier functions** return a modified version of the abstraction.
* **Query functions** return computed data without changing the abstraction.

This design pattern makes modules composable, reusable, and “pipe-friendly.”

---

## Abstracting with Modules

Example: using **MapSet**

```elixir
days = 
  MapSet.new()
  |> MapSet.put(:monday)
  |> MapSet.put(:tuesday)

MapSet.member?(days, :monday) # true
```

All MapSet functions accept a set as their first argument, making them perfect for use with the `|>` (pipe) operator — a natural fit for Elixir’s abstraction design.

---

## Composing Abstractions

You can build abstractions on top of others.
Example — `MultiDict`: a general-purpose multi-value dictionary.

```elixir
defmodule MultiDict do
  def new(), do: %{}
  def add(dict, key, value),
    do: Map.update(dict, key, [value], &[value | &1])
  def get(dict, key),
    do: Map.get(dict, key, [])
end
```

Then, a higher-level abstraction `TodoList` can reuse it:

```elixir
defmodule TodoList do
  def new(), do: MultiDict.new()
  def add_entry(todo_list, date, title),
    do: MultiDict.add(todo_list, date, title)
  def entries(todo_list, date),
    do: MultiDict.get(todo_list, date)
end
```

✅ This is **separation of concerns** — reusable abstractions layered cleanly.

---

## Structuring Data with Maps

If you later need to add new fields (like `time`), changing function signatures everywhere becomes painful.
A better way is to **encapsulate all entry attributes** in one data structure:

```elixir
def add_entry(todo_list, entry) do
  MultiDict.add(todo_list, entry.date, entry)
end
```

Now `entry` is a single, structured map — a step toward defining a **struct**.

---

## Abstracting with Structs

A **struct** is a predefined map associated with a module.

```elixir
defmodule Fraction do
  defstruct a: nil, b: nil
end
```

* A struct **must belong to a module**, and each module defines **only one struct**.
* Its **shape is fixed at compile time**, enabling compile-time error checking.
* Structs improve **clarity and safety** over raw maps.

---

### Structs vs. Maps

Structs are implemented **on top of maps**, but differ in behavior:

```elixir
one_half = %Fraction{a: 1, b: 2}

Enum.to_list(one_half)
# ** (Protocol.UndefinedError)
```

Structs are **not Enumerable** by default — they only expose what the defining module specifies.

Compare:

```elixir
Enum.to_list(%{a: 1, b: 2}) 
# [a: 1, b: 2]
Map.to_list(one_half)
# [__struct__: Fraction, a: 1, b: 2]
```

Structs include an internal `__struct__` field for type identification.

**Pattern Matching:**

```elixir
%Fraction{a: a, b: b} = %{a: 1, b: 2}   # MatchError
%{a: a, b: b} = %Fraction{a: 1, b: 2}   # OK
```

➡ Structs can match maps, but not vice versa.

---

### Records

* **Records** use tuples with named fields.
* Defined with `defrecord` or `defrecordp`.
* Historically common in Erlang libraries.
  Example:

  ```elixir
  defrecord :user, name: nil, age: nil
  ```
* Mostly replaced by **maps/structs**, but still appear in legacy code.

---

## Data Transparency

Elixir encourages **data transparency** — internal data structures are *visible*.

```elixir
todo_list = TodoList.new()
|> TodoList.add_entry(%{date: ~D[2023-12-19], title: "Dentist"})
# => %{~D[2023-12-19] => [%{date: ~D[2023-12-19], title: "Dentist"}]}
```

* You can always **see the structure**, useful for debugging.
* But you **should not rely** on internal representation — use module APIs.

All abstractions (`MapSet`, `TodoList`, etc.) ultimately build on **maps, lists, and tuples**.

---

## Working with Hierarchical Data

### Generating IDs

Refactor `TodoList` to manage entries via IDs and internal state using a **struct**.

```elixir
defmodule TodoList do
  defstruct next_id: 1, entries: %{}

  def new(), do: %TodoList{}

  def add_entry(todo_list, entry) do
    entry = Map.put(entry, :id, todo_list.next_id)
    new_entries = Map.put(todo_list.entries, todo_list.next_id, entry)
    %TodoList{todo_list | entries: new_entries, next_id: todo_list.next_id + 1}
  end

  def entries(todo_list, date) do
    todo_list.entries
    |> Map.values()
    |> Enum.filter(fn entry -> entry.date == date end)
  end
end
```

* Uses **IDs** as keys for efficient lookup and updates.
* Eliminates need for `MultiDict`.
* Maintains **next_id** as internal state.

---

### Updating Entries

```elixir
def update_entry(todo_list, entry_id, updater_fun) do
  case Map.fetch(todo_list.entries, entry_id) do
    :error -> todo_list
    {:ok, old_entry} ->
      new_entry = updater_fun.(old_entry)
      new_entries = Map.put(todo_list.entries, new_entry.id, new_entry)
      %TodoList{todo_list | entries: new_entries}
  end
end
```

* Uses **Map.fetch/2** for safe lookup.
* Updates only if entry exists.
* Returns a **new modified struct**, preserving immutability.

---

### Immutable Hierarchical Updates

When dealing with nested immutable data:

* You cannot modify in place.
* You rebuild the data tree by updating the modified node and its ancestors.
* BEAM runtime optimizes shared memory — efficient even with copies.

---

### Iterative Updates

Build `TodoList` from multiple entries:

```elixir
def new(entries \\ []) do
  Enum.reduce(entries, %TodoList{}, &add_entry(&2, &1))
end
```

* Uses `Enum.reduce/3` to fold a list of entries into a complete struct.
* Demonstrates how functional iteration replaces loops.

---

## Polymorphism with Protocols

### Protocol Basics

Protocols allow **runtime polymorphism** (like interfaces in OOP).

```elixir
defprotocol String.Chars do
  def to_string(term)
end
```

Runtime dispatch:

```elixir
String.Chars.to_string(1)          # "1"
String.Chars.to_string(:an_atom)   # "an_atom"
```

If not implemented:

```elixir
String.Chars.to_string(TodoList.new())
# ** (Protocol.UndefinedError)
```

The protocol is used implicitly by generic functions like:

```elixir
to_string(1)
to_string(:ok)
```

which delegate to `String.Chars`.

---

### Implementing a Protocol

You can implement a protocol for a type using `defimpl`:

```elixir
defimpl String.Chars, for: Integer do
  def to_string(term), do: Integer.to_string(term)
end
```

* `for:` specifies which type to support.
* Types can be: `Integer`, `Atom`, `List`, `Tuple`, `Map`, etc.
* Or your **custom struct alias**:

  ```elixir
  defimpl String.Chars, for: TodoList do
    def to_string(_), do: "#TodoList"
  end
  ```
* Protocol implementations can live **outside the module** — enabling extension of 3rd-party types.

---

### Built-in Protocols

Elixir’s **most important protocol** is `Enumerable`.

Implementing it makes your data structure usable with all:

* `Enum.*` functions
* `Stream.*` pipelines

This enables full iteration and transformation functionality.

---

### Collectable TodoList Example

To make your abstraction **collectable**, implement `Collectable`:

```elixir
defimpl Collectable, for: TodoList do
  def into(original), do: {original, &into_callback/2}

  defp into_callback(todo_list, {:cont, entry}),
    do: TodoList.add_entry(todo_list, entry)

  defp into_callback(todo_list, :done), do: todo_list
  defp into_callback(_todo_list, :halt), do: :ok
end
```

* `into/1` is called by generic code (like comprehensions).
* It returns an accumulator and an **appender function** (`into_callback/2`).
* This function defines **how elements are inserted** into your custom structure.

---

## Key Takeaways

* **Modules** encapsulate behaviors and act as abstraction boundaries.
* **Composing abstractions** (e.g., `MultiDict` + `TodoList`) improves modularity.
* **Structs** formalize data structure with compile-time shape validation.
* **Data transparency** allows visibility but encourages API-level interaction.
* **Protocols** enable polymorphism — dynamic behavior based on data type.
* Implementing **Collectable** and **Enumerable** integrates your abstractions with Elixir’s ecosystem.
* Functional principles (immutability, composition, pattern matching) underpin every abstraction layer.