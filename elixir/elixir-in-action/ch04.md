# 4ì¥. ë°ì´í„° ì¶”ìƒí™” (Data Abstractions)

## ğŸ“‘ ëª©ì°¨

- [4ì¥. ë°ì´í„° ì¶”ìƒí™” (Data Abstractions)](#4ì¥-ë°ì´í„°-ì¶”ìƒí™”-data-abstractions)
  - [ğŸ“‘ ëª©ì°¨](#-ëª©ì°¨)
  - [ì¶”ìƒí™”ì˜ ê¸°ë³¸ ì›ì¹™](#ì¶”ìƒí™”ì˜-ê¸°ë³¸-ì›ì¹™)
  - [ëª¨ë“ˆë¡œ ì¶”ìƒí™”í•˜ê¸°](#ëª¨ë“ˆë¡œ-ì¶”ìƒí™”í•˜ê¸°)
  - [ì¶”ìƒí™”ì˜ êµ¬ì„±(Composing Abstractions)](#ì¶”ìƒí™”ì˜-êµ¬ì„±composing-abstractions)
  - [ë§µ(Map)ìœ¼ë¡œ ë°ì´í„° êµ¬ì¡°í™”í•˜ê¸°](#ë§µmapìœ¼ë¡œ-ë°ì´í„°-êµ¬ì¡°í™”í•˜ê¸°)
  - [Structë¡œ ì¶”ìƒí™”í•˜ê¸°](#structë¡œ-ì¶”ìƒí™”í•˜ê¸°)
    - [Structì™€ Map ë¹„êµ](#structì™€-map-ë¹„êµ)
    - [Record(ë ˆì½”ë“œ)](#recordë ˆì½”ë“œ)
  - [ë°ì´í„° íˆ¬ëª…ì„±(Data Transparency)](#ë°ì´í„°-íˆ¬ëª…ì„±data-transparency)
  - [ê³„ì¸µì  ë°ì´í„° ë‹¤ë£¨ê¸°](#ê³„ì¸µì -ë°ì´í„°-ë‹¤ë£¨ê¸°)
    - [ID ìë™ ìƒì„±](#id-ìë™-ìƒì„±)
    - [ì—”íŠ¸ë¦¬ ì—…ë°ì´íŠ¸](#ì—”íŠ¸ë¦¬-ì—…ë°ì´íŠ¸)
    - [ë¶ˆë³€ ê³„ì¸µ êµ¬ì¡° ì—…ë°ì´íŠ¸](#ë¶ˆë³€-ê³„ì¸µ-êµ¬ì¡°-ì—…ë°ì´íŠ¸)
    - [ë°˜ë³µì  ì—…ë°ì´íŠ¸](#ë°˜ë³µì -ì—…ë°ì´íŠ¸)
  - [í”„ë¡œí† ì½œì„ í†µí•œ ë‹¤í˜•ì„±](#í”„ë¡œí† ì½œì„-í†µí•œ-ë‹¤í˜•ì„±)
    - [í”„ë¡œí† ì½œ ê¸°ë³¸ ê°œë…](#í”„ë¡œí† ì½œ-ê¸°ë³¸-ê°œë…)
    - [í”„ë¡œí† ì½œ êµ¬í˜„í•˜ê¸°](#í”„ë¡œí† ì½œ-êµ¬í˜„í•˜ê¸°)
    - [ë‚´ì¥ í”„ë¡œí† ì½œê³¼ Collectable ì˜ˆì‹œ](#ë‚´ì¥-í”„ë¡œí† ì½œê³¼-collectable-ì˜ˆì‹œ)
  - [í•µì‹¬ ìš”ì•½](#í•µì‹¬-ìš”ì•½)

---

## ì¶”ìƒí™”ì˜ ê¸°ë³¸ ì›ì¹™

Elixirì˜ ë°ì´í„° ì¶”ìƒí™”ëŠ” ë‹¤ìŒ ì›ì¹™ì„ ë”°ë¦…ë‹ˆë‹¤:

* **ëª¨ë“ˆ(Module)** ì€ íŠ¹ì • ë™ì‘(behavior)ì„ ì¶”ìƒí™”í•˜ëŠ” ë‹¨ìœ„ì´ë‹¤.
* í•¨ìˆ˜ëŠ” ë³´í†µ **ì¶”ìƒí™” ì¸ìŠ¤í„´ìŠ¤(ë°ì´í„° êµ¬ì¡°)** ë¥¼ ì²« ë²ˆì§¸ ì¸ìë¡œ ë°›ëŠ”ë‹¤.
* **ìˆ˜ì • í•¨ìˆ˜(modifier)** ëŠ” ìˆ˜ì •ëœ ë²„ì „ì˜ ì¶”ìƒí™”ë¥¼ ë°˜í™˜í•œë‹¤.
* **ì¡°íšŒ í•¨ìˆ˜(query)** ëŠ” ë°ì´í„°ë¥¼ ì½ê¸°ë§Œ í•˜ê³  ë‹¤ë¥¸ ê°’ì„ ë°˜í™˜í•œë‹¤.

ì´ëŸ¬í•œ ì„¤ê³„ ë•ë¶„ì— Elixirì˜ ëª¨ë“ˆì€ **ì¡°í•© ê°€ëŠ¥í•˜ê³ (pipe ì—°ì‚°ìì™€ í˜¸í™˜ë˜ëŠ”)** í•¨ìˆ˜í˜• ì¶”ìƒí™”ë¡œ ì‘ë™í•©ë‹ˆë‹¤.

---

## ëª¨ë“ˆë¡œ ì¶”ìƒí™”í•˜ê¸°

ì˜ˆì‹œ â€” `MapSet` ì‚¬ìš©:

```elixir
days = 
  MapSet.new()
  |> MapSet.put(:monday)
  |> MapSet.put(:tuesday)

MapSet.member?(days, :monday) # true
```

ëª¨ë“  í•¨ìˆ˜ê°€ ì²« ë²ˆì§¸ ì¸ìë¡œ `MapSet` ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°›ê¸° ë•Œë¬¸ì—
`|>` íŒŒì´í”„ ì—°ì‚°ìë¥¼ ì´ìš©í•´ ìì—°ìŠ¤ëŸ½ê²Œ ì—°ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

## ì¶”ìƒí™”ì˜ êµ¬ì„±(Composing Abstractions)

ë³µì¡í•œ ì¶”ìƒí™”ëŠ” ë” ë‹¨ìˆœí•œ ì¶”ìƒí™”ì˜ ì¡°í•©ìœ¼ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤.

ì˜ˆ: ì—¬ëŸ¬ ê°’ì„ í•˜ë‚˜ì˜ í‚¤ì— ì €ì¥í•˜ëŠ” `MultiDict` ëª¨ë“ˆ

```elixir
defmodule MultiDict do
  def new(), do: %{}
  def add(dict, key, value),
    do: Map.update(dict, key, [value], &[value | &1])
  def get(dict, key),
    do: Map.get(dict, key, [])
end
```

ì´ì œ ì´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ `TodoList`ë¥¼ ë‹¨ìˆœí™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```elixir
defmodule TodoList do
  def new(), do: MultiDict.new()
  def add_entry(todo_list, date, title),
    do: MultiDict.add(todo_list, date, title)
  def entries(todo_list, date),
    do: MultiDict.get(todo_list, date)
end
```

â¡ï¸ **ê´€ì‹¬ì‚¬ì˜ ë¶„ë¦¬(Separation of Concerns)** â€” ê° ëª¨ë“ˆì€ í•˜ë‚˜ì˜ ì—­í• ë§Œ ë‹´ë‹¹í•©ë‹ˆë‹¤.

---

## ë§µ(Map)ìœ¼ë¡œ ë°ì´í„° êµ¬ì¡°í™”í•˜ê¸°

ìƒˆë¡œìš´ ì†ì„±ì„ ì¶”ê°€í•´ì•¼ í•  ë•Œë§ˆë‹¤ í•¨ìˆ˜ ì¸ìë¥¼ ìˆ˜ì •í•˜ë©´ ìœ ì§€ë³´ìˆ˜ê°€ ì–´ë ¤ì›Œì§‘ë‹ˆë‹¤.
ë”°ë¼ì„œ ì—”íŠ¸ë¦¬ì˜ ì†ì„±ì„ í•˜ë‚˜ì˜ êµ¬ì¡°ë¡œ ë¬¶ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.

```elixir
def add_entry(todo_list, entry) do
  MultiDict.add(todo_list, entry.date, entry)
end
```

ì´ì œ `entry`ëŠ” í•˜ë‚˜ì˜ êµ¬ì¡°í™”ëœ ë°ì´í„°(Map)ë¡œ ê´€ë¦¬ë©ë‹ˆë‹¤.

---

## Structë¡œ ì¶”ìƒí™”í•˜ê¸°

StructëŠ” **ëª¨ë“ˆì— ì—°ê²°ëœ ë¯¸ë¦¬ ì •ì˜ëœ Map í˜•íƒœ**ì…ë‹ˆë‹¤.

```elixir
defmodule Fraction do
  defstruct a: nil, b: nil
end
```

* StructëŠ” í•­ìƒ **ëª¨ë“ˆ ë‚´ë¶€ì— ì •ì˜**ë˜ë©°, **ëª¨ë“ˆë‹¹ í•˜ë‚˜**ë§Œ ì¡´ì¬í•©ë‹ˆë‹¤.
* Structì˜ **í˜•íƒœ(shape)** ëŠ” **ì»´íŒŒì¼ ì‹œì ì— ê³ ì •**ë˜ì–´, íƒ€ì… ì˜¤ë¥˜ë¥¼ ë¯¸ë¦¬ ë°©ì§€í•©ë‹ˆë‹¤.
* ë‹¨ìˆœ Mapë³´ë‹¤ **ì•ˆì •ì„±ê³¼ ëª…í™•ì„±**ì„ ì œê³µí•©ë‹ˆë‹¤.

---

### Structì™€ Map ë¹„êµ

StructëŠ” Map ê¸°ë°˜ì´ì§€ë§Œ ë‹¤ë¥´ê²Œ ë™ì‘í•©ë‹ˆë‹¤:

```elixir
one_half = %Fraction{a: 1, b: 2}

Enum.to_list(one_half)
# ** (Protocol.UndefinedError)
```

StructëŠ” ê¸°ë³¸ì ìœ¼ë¡œ Enumerableì´ ì•„ë‹ˆë©°, ëª…ì‹œì ìœ¼ë¡œ ì •ì˜í•´ì•¼ í•©ë‹ˆë‹¤.

```elixir
Enum.to_list(%{a: 1, b: 2}) 
# [a: 1, b: 2]
Map.to_list(one_half)
# [__struct__: Fraction, a: 1, b: 2]
```

**íŒ¨í„´ ë§¤ì¹­**

```elixir
%Fraction{a: a, b: b} = %{a: 1, b: 2}   # MatchError
%{a: a, b: b} = %Fraction{a: 1, b: 2}   # OK
```

â¡ StructëŠ” Mapì„ ë§¤ì¹­í•  ìˆ˜ ìˆì§€ë§Œ, ë°˜ëŒ€ëŠ” ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.

---

### Record(ë ˆì½”ë“œ)

* Tuple ê¸°ë°˜ìœ¼ë¡œ ë°ì´í„°ë¥¼ ì´ë¦„ìœ¼ë¡œ ì ‘ê·¼í•  ìˆ˜ ìˆê²Œ í•œ êµ¬ì¡°.
* `defrecord`, `defrecordp` ë§¤í¬ë¡œë¡œ ì •ì˜.
* Erlang ì‹œì ˆì˜ ìœ ì‚°ìœ¼ë¡œ, **ì´ì „ ë¼ì´ë¸ŒëŸ¬ë¦¬**ì—ì„œëŠ” ì—¬ì „íˆ ì‚¬ìš©ë©ë‹ˆë‹¤.
* í˜„ì¬ëŠ” ëŒ€ë¶€ë¶„ Structì™€ Mapìœ¼ë¡œ ëŒ€ì²´ë¨.

---

## ë°ì´í„° íˆ¬ëª…ì„±(Data Transparency)

Elixirì—ì„œëŠ” ë°ì´í„°ê°€ **í•­ìƒ ë…¸ì¶œë˜ê³  ì½ì„ ìˆ˜ ìˆìŒ**ì´ ê¸°ë³¸ ì² í•™ì…ë‹ˆë‹¤.

```elixir
todo_list =
  TodoList.new()
  |> TodoList.add_entry(%{date: ~D[2023-12-19], title: "Dentist"})
# %{~D[2023-12-19] => [%{date: ~D[2023-12-19], title: "Dentist"}]}
```

* ë°ì´í„° êµ¬ì¡°ë¥¼ ê·¸ëŒ€ë¡œ í™•ì¸í•  ìˆ˜ ìˆì–´ **ë””ë²„ê¹…ì— ìœ ìš©**í•©ë‹ˆë‹¤.
* í•˜ì§€ë§Œ ë‚´ë¶€ êµ¬ì¡°ì— **ì§ì ‘ ì˜ì¡´í•˜ê±°ë‚˜ ìˆ˜ì •í•˜ë©´ ì•ˆ ë©ë‹ˆë‹¤.**
  ëª¨ë“ˆì´ ì œê³µí•˜ëŠ” API í•¨ìˆ˜ë§Œ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì›ì¹™ì…ë‹ˆë‹¤.

ëª¨ë“  ë³µì¡í•œ ì¶”ìƒí™”(`MapSet`, `TodoList`)ëŠ” ê²°êµ­
**íŠœí”Œ, ë¦¬ìŠ¤íŠ¸, ë§µ** ìœ„ì—ì„œ êµ¬ì¶•ë©ë‹ˆë‹¤.

---

## ê³„ì¸µì  ë°ì´í„° ë‹¤ë£¨ê¸°

### ID ìë™ ìƒì„±

`TodoList`ë¥¼ Structë¡œ ë³€ê²½í•˜ì—¬ IDë¥¼ ìë™ ìƒì„±í•˜ê³  ê´€ë¦¬í•©ë‹ˆë‹¤.

```elixir
defmodule TodoList do
  defstruct next_id: 1, entries: %{}

  def new(), do: %TodoList{}

  def add_entry(todo_list, entry) do
    entry = Map.put(entry, :id, todo_list.next_id)
    new_entries = Map.put(todo_list.entries, todo_list.next_id, entry)
    %TodoList{todo_list | entries: new_entries, next_id: todo_list.next_id + 1}
  end

  def entries(todo_list, date) do
    todo_list.entries
    |> Map.values()
    |> Enum.filter(fn entry -> entry.date == date end)
  end
end
```

* `next_id`ë¡œ ê³ ìœ  ID ê´€ë¦¬
* ID ê¸°ë°˜ ì¡°íšŒë¡œ ë¹ ë¥¸ ì—…ë°ì´íŠ¸ ê°€ëŠ¥
* `MultiDict` ë¶ˆí•„ìš”

---

### ì—”íŠ¸ë¦¬ ì—…ë°ì´íŠ¸

```elixir
def update_entry(todo_list, entry_id, updater_fun) do
  case Map.fetch(todo_list.entries, entry_id) do
    :error -> todo_list
    {:ok, old_entry} ->
      new_entry = updater_fun.(old_entry)
      new_entries = Map.put(todo_list.entries, new_entry.id, new_entry)
      %TodoList{todo_list | entries: new_entries}
  end
end
```

* `Map.fetch/2` ë¡œ ì•ˆì „í•œ ì¡°íšŒ
* ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ ì›ë³¸ ë°˜í™˜
* í•­ìƒ ìƒˆë¡œìš´ êµ¬ì¡°ì²´ë¥¼ ë°˜í™˜ (ë¶ˆë³€ì„± ìœ ì§€)

---

### ë¶ˆë³€ ê³„ì¸µ êµ¬ì¡° ì—…ë°ì´íŠ¸

ElixirëŠ” **ë¶ˆë³€ ë°ì´í„°**ë¥¼ ì›ì¹™ìœ¼ë¡œ í•©ë‹ˆë‹¤.
ë”°ë¼ì„œ ê¹Šì€ êµ¬ì¡°ë¥¼ ë³€ê²½í•  ë•ŒëŠ”:

* íŠ¸ë¦¬ë¥¼ ë”°ë¼ê°€ë©° ë³€ê²½í•  ë¶€ë¶„ì„ ìƒˆë¡œ ìƒì„±
* ë¶€ëª¨ ë…¸ë“œë„ í•¨ê»˜ ìƒˆë¡œ êµ¬ì„±
* ë©”ëª¨ë¦¬ëŠ” ê³µìœ ë˜ì–´ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬ë¨

---

### ë°˜ë³µì  ì—…ë°ì´íŠ¸

ì—¬ëŸ¬ ì—”íŠ¸ë¦¬ë¥¼ ê°€ì§„ TodoList ìƒì„±:

```elixir
def new(entries \\ []) do
  Enum.reduce(entries, %TodoList{}, &add_entry(&2, &1))
end
```

* `Enum.reduce/3` ë¡œ ë¦¬ìŠ¤íŠ¸ë¥¼ êµ¬ì¡°ì²´ë¡œ ì¶•ì•½
* ëˆ„ì‚°ê¸°(accumulator) ì—­í• ì„ í•˜ëŠ” `TodoList`ë¥¼ ê°±ì‹ 

---

## í”„ë¡œí† ì½œì„ í†µí•œ ë‹¤í˜•ì„±

### í”„ë¡œí† ì½œ ê¸°ë³¸ ê°œë…

Elixirì˜ **í”„ë¡œí† ì½œ(protocol)** ì€ ëŸ°íƒ€ì„ì— ì…ë ¥ ë°ì´í„° íƒ€ì…ì— ë”°ë¼ ì‹¤í–‰ ì½”ë“œë¥¼ ê²°ì •í•˜ëŠ” **ë‹¤í˜•ì„±(polymorphism)** ë©”ì»¤ë‹ˆì¦˜ì…ë‹ˆë‹¤.

```elixir
defprotocol String.Chars do
  def to_string(term)
end
```

```elixir
String.Chars.to_string(1)          # "1"
String.Chars.to_string(:atom)      # "atom"
```

ë¯¸êµ¬í˜„ íƒ€ì…ì€ ì˜¤ë¥˜ ë°œìƒ:

```elixir
String.Chars.to_string(TodoList.new())
# ** (Protocol.UndefinedError)
```

ë³´í†µì€ ì§ì ‘ í˜¸ì¶œí•˜ì§€ ì•Šê³ ,
`to_string/1` ê°™ì€ **Kernel í•¨ìˆ˜**ê°€ ë‚´ë¶€ì ìœ¼ë¡œ í”„ë¡œí† ì½œì„ í˜¸ì¶œí•©ë‹ˆë‹¤.

---

### í”„ë¡œí† ì½œ êµ¬í˜„í•˜ê¸°

íŠ¹ì • íƒ€ì…ì— ëŒ€í•´ í”„ë¡œí† ì½œì„ êµ¬í˜„í•˜ë ¤ë©´ `defimpl` ì‚¬ìš©:

```elixir
defimpl String.Chars, for: Integer do
  def to_string(term), do: Integer.to_string(term)
end
```

* `for:` ë’¤ì— êµ¬í˜„í•  íƒ€ì… ì§€ì • (ì˜ˆ: `Integer`, `List`, `Map`, ì‚¬ìš©ì ì •ì˜ Struct ë“±)
* `Any`ë¡œ ì§€ì •í•˜ë©´ **ëª¨ë“  íƒ€ì…ì˜ ê¸°ë³¸ êµ¬í˜„(fallback)** ì´ ë¨.

ì‚¬ìš©ì ì •ì˜ Structì— ëŒ€í•œ êµ¬í˜„ ì˜ˆì‹œ:

```elixir
defimpl String.Chars, for: TodoList do
  def to_string(_), do: "#TodoList"
end
```

ğŸ’¡ **íƒ€ì…ì˜ ì†ŒìŠ¤ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì§€ ì•Šì•„ë„**
ë³„ë„ íŒŒì¼ì— í”„ë¡œí† ì½œ êµ¬í˜„ì„ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

### ë‚´ì¥ í”„ë¡œí† ì½œê³¼ Collectable ì˜ˆì‹œ

ê°€ì¥ ì¤‘ìš”í•œ í”„ë¡œí† ì½œ ì¤‘ í•˜ë‚˜ëŠ” **Enumerable**ì…ë‹ˆë‹¤.
ì´ë¥¼ êµ¬í˜„í•˜ë©´ `Enum`, `Stream` ëª¨ë“ˆì˜ ëª¨ë“  ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë˜ ë‹¤ë¥¸ ì˜ˆ â€” `Collectable` í”„ë¡œí† ì½œ:

```elixir
defimpl Collectable, for: TodoList do
  def into(original), do: {original, &into_callback/2}

  defp into_callback(todo_list, {:cont, entry}),
    do: TodoList.add_entry(todo_list, entry)

  defp into_callback(todo_list, :done), do: todo_list
  defp into_callback(_todo_list, :halt), do: :ok
end
```

* `into/1` ì€ **ìˆ˜ì§‘ê¸°(appender)** ì—­í• ì„ í•˜ëŠ” í•¨ìˆ˜ë¥¼ ë°˜í™˜
* `{:cont, entry}` â†’ ìƒˆ í•­ëª© ì¶”ê°€
* `:done` â†’ ìµœì¢… ë°˜í™˜
* `:halt` â†’ ì¤‘ë‹¨ ì‹œ ì²˜ë¦¬

---

## í•µì‹¬ ìš”ì•½

* **ëª¨ë“ˆ**ì€ ë°ì´í„°ì™€ ë™ì‘ì„ í•¨ê»˜ ì¶”ìƒí™”í•œë‹¤.
* **í•¨ìˆ˜í˜• ì„¤ê³„ ì›ì¹™**(ë¶ˆë³€ì„±, ì¡°í•©ì„±, íŒ¨í„´ ë§¤ì¹­)ì´ ëª¨ë“  ì¶”ìƒí™”ì˜ ê¸°ì´ˆë‹¤.
* **Struct**ëŠ” Mapë³´ë‹¤ ì•ˆì „í•˜ê³  ì»´íŒŒì¼ ì‹œì  ê²€ì¦ì´ ê°€ëŠ¥í•˜ë‹¤.
* **ë°ì´í„° íˆ¬ëª…ì„±**ì€ ë””ë²„ê¹…ì— ìœ ìš©í•˜ì§€ë§Œ ë‚´ë¶€ êµ¬ì¡° ì˜ì¡´ì€ ê¸ˆì§€ëœë‹¤.
* **í”„ë¡œí† ì½œ**ì„ êµ¬í˜„í•˜ë©´ ëŸ°íƒ€ì„ ë‹¤í˜•ì„±ì„ ì‰½ê²Œ ë‹¬ì„±í•  ìˆ˜ ìˆë‹¤.
* **Collectable / Enumerable** í”„ë¡œí† ì½œì€ ì¶”ìƒí™”ë¥¼ Elixir í‘œì¤€ ì»¬ë ‰ì…˜ì²˜ëŸ¼ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•œë‹¤.

