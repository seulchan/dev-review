# Chapter 3. ì œì–´ íë¦„ (Control Flow)

## ğŸ“‘ ëª©ì°¨

1. [íŒ¨í„´ ë§¤ì¹­ (Pattern Matching)](#íŒ¨í„´-ë§¤ì¹­-pattern-matching)

   * [ë§¤ì¹˜ ì—°ì‚°ì](#ë§¤ì¹˜-ì—°ì‚°ì)
   * [íŠœí”Œ ë§¤ì¹­](#íŠœí”Œ-ë§¤ì¹­)
   * [ìƒìˆ˜ ë§¤ì¹­](#ìƒìˆ˜-ë§¤ì¹­)
   * [ë³€ìˆ˜ì™€ í•€ ì—°ì‚°ì](#ë³€ìˆ˜ì™€-í•€-ì—°ì‚°ì)
   * [ë¦¬ìŠ¤íŠ¸ ë§¤ì¹­](#ë¦¬ìŠ¤íŠ¸-ë§¤ì¹­)
   * [ë§µ ë§¤ì¹­](#ë§µ-ë§¤ì¹­)
   * [ë°”ì´ë„ˆë¦¬ ë§¤ì¹­](#ë°”ì´ë„ˆë¦¬-ë§¤ì¹­)
   * [ë³µí•© ë§¤ì¹­](#ë³µí•©-ë§¤ì¹­)
   * [íŒ¨í„´ ë§¤ì¹­ì˜ ì¼ë°˜ ë™ì‘](#íŒ¨í„´-ë§¤ì¹­ì˜-ì¼ë°˜-ë™ì‘)
2. [í•¨ìˆ˜ì™€ íŒ¨í„´ ë§¤ì¹­](#í•¨ìˆ˜ì™€-íŒ¨í„´-ë§¤ì¹­)

   * [ë‹¤ì¤‘ ì ˆ í•¨ìˆ˜ (Multiclause Functions)](#ë‹¤ì¤‘-ì ˆ-í•¨ìˆ˜-multiclause-functions)
   * [ê°€ë“œ (Guards)](#ê°€ë“œ-guards)
   * [ë‹¤ì¤‘ ì ˆ ëŒë‹¤ (Multiclause Lambdas)](#ë‹¤ì¤‘-ì ˆ-ëŒë‹¤-multiclause-lambdas)
3. [ì¡°ê±´ë¬¸](#ì¡°ê±´ë¬¸)

   * [í•¨ìˆ˜ë¥¼ ì´ìš©í•œ ë¶„ê¸°](#í•¨ìˆ˜ë¥¼-ì´ìš©í•œ-ë¶„ê¸°)
   * [ì „í†µì  ë¶„ê¸°ë¬¸ (if, unless, cond, case)](#ì „í†µì -ë¶„ê¸°ë¬¸-if-unless-cond-case)
   * [with í‘œí˜„ì‹](#with-í‘œí˜„ì‹)
4. [ë°˜ë³µê³¼ ìˆœíšŒ](#ë°˜ë³µê³¼-ìˆœíšŒ)

   * [ì¬ê·€ë¥¼ ì´ìš©í•œ ë°˜ë³µ](#ì¬ê·€ë¥¼-ì´ìš©í•œ-ë°˜ë³µ)
   * [ê¼¬ë¦¬ ì¬ê·€ (Tail Recursion)](#ê¼¬ë¦¬-ì¬ê·€-tail-recursion)
   * [ê³ ì°¨ í•¨ìˆ˜ (Higher-Order Functions)](#ê³ ì°¨-í•¨ìˆ˜-higher-order-functions)
   * [ë‚´í¬ (Comprehensions)](#ë‚´í¬-comprehensions)
   * [ìŠ¤íŠ¸ë¦¼ (Streams)](#ìŠ¤íŠ¸ë¦¼-streams)
5. [í•µì‹¬ ìš”ì•½](#í•µì‹¬-ìš”ì•½)

---

## íŒ¨í„´ ë§¤ì¹­ (Pattern Matching)

### ë§¤ì¹˜ ì—°ì‚°ì

* `=`ëŠ” **í• ë‹¹(assign)** ì´ ì•„ë‹Œ **ë§¤ì¹­(match)** ì—°ì‚°ìì´ë‹¤.

* ì™¼ìª½ì€ **íŒ¨í„´**, ì˜¤ë¥¸ìª½ì€ **ê°’(term)**

  ```elixir
  {name, age} = {"Bob", 25}
  ```

  â†’ `name = "Bob"`, `age = 25`

* ë¶ˆì¼ì¹˜ ì‹œ ì˜¤ë¥˜ ë°œìƒ:

  ```elixir
  {name, age} = "can't match"
  # ** (MatchError)
  ```

* ë°˜í™˜ê°’ì€ í•­ìƒ **ì˜¤ë¥¸ìª½ ê°’**ì´ë‹¤.

---

### íŠœí”Œ ë§¤ì¹­

```elixir
{name, age} = {"Alice", 30}
```

* ì˜¤ë¥¸ìª½ ê°’ì´ `{}` í˜•íƒœì¼ ë•Œë§Œ ë§¤ì¹­ëœë‹¤.
* êµ¬ì¡°ê°€ ë‹¤ë¥´ë©´ **MatchError** ë°œìƒ.

---

### ìƒìˆ˜ ë§¤ì¹­

* ì™¼ìª½ì— ìƒìˆ˜ë„ ê°€ëŠ¥:

  ```elixir
  1 = 1  # OK
  1 = 2  # ì˜¤ë¥˜
  ```

* ì˜ˆì‹œ: íŒŒì¼ ì½ê¸° ì‹œ íŒ¨í„´ ì‚¬ìš©

  ```elixir
  {:ok, contents} = File.read("config.txt")
  ```

  â†’ ì‹¤íŒ¨ ì‹œ `{:error, reason}`ìœ¼ë¡œ ë§¤ì¹­ ì‹¤íŒ¨.

---

### ë³€ìˆ˜ì™€ í•€ ì—°ì‚°ì

* `_` : ì•„ë¬´ ê°’ì´ë‚˜ ë§¤ì¹­í•˜ì§€ë§Œ ë°”ì¸ë”©í•˜ì§€ ì•ŠìŒ

  ```elixir
  {_, time} = :calendar.local_time()
  ```

* `_date` : ë³€ìˆ˜ëª… ì•ì— `_`ê°€ ìˆìœ¼ë©´ â€œë¬´ì‹œâ€ ë³€ìˆ˜ë¡œ ê°„ì£¼.

* **í•€ ì—°ì‚°ì `^`** : ì´ë¯¸ ë°”ì¸ë”©ëœ ê°’ê³¼ ë¹„êµ

  ```elixir
  expected = "Bob"
  {^expected, _} = {"Bob", 25}  # OK
  {^expected, _} = {"Alice", 30} # ì˜¤ë¥˜
  ```

---

### ë¦¬ìŠ¤íŠ¸ ë§¤ì¹­

```elixir
[first, second, third] = [1, 2, 3]
[first, _] = [1, 2]
[^first, _] = [1, 3]  # ë§¤ì¹­ ì‹¤íŒ¨
```

---

### ë§µ ë§¤ì¹­

* ë¶€ë¶„ ë§¤ì¹­ ê°€ëŠ¥:

  ```elixir
  %{name: name, age: age} = %{name: "Bob", age: 25}
  %{age: age} = %{name: "Bob", age: 25}
  ```
* ì¡´ì¬ í•˜ì§€ ì•ŠëŠ” í‚¤ í¬í•¨ ì‹œ ì‹¤íŒ¨:

  ```elixir
  %{age: age, job: job} = %{name: "Bob", age: 25}
  # MatchError
  ```

---

### ë°”ì´ë„ˆë¦¬ ë§¤ì¹­

```elixir
<<a, b, c>> = <<1, 2, 3>>
<<first, rest::binary>> = <<1, 2, 3>>
<<hi::4, lo::4>> = <<155>> # hi=9, lo=11
```

* ë¬¸ìì—´ë„ ì´ì§„(binary)ìœ¼ë¡œ ë‹¤ë£° ìˆ˜ ìˆìŒ:

  ```elixir
  "ping " <> url = "ping www.example.com"
  url # "www.example.com"
  ```

---

### ë³µí•© ë§¤ì¹­

íŒ¨í„´ì„ ì¤‘ì²© ê°€ëŠ¥:

```elixir
[_, {name, _}, _] = [{"Bob", 25}, {"Alice", 30}, {"John", 35}]
```

---

### íŒ¨í„´ ë§¤ì¹­ì˜ ì¼ë°˜ ë™ì‘

1. ì˜¤ë¥¸ìª½ í‘œí˜„ì‹ì„ í‰ê°€
2. ì™¼ìª½ íŒ¨í„´ê³¼ ë¹„êµ
3. ì¼ì¹˜ ì‹œ ë³€ìˆ˜ ë°”ì¸ë”©
4. ê²°ê³¼ëŠ” ì˜¤ë¥¸ìª½ ê°’
5. ë¶ˆì¼ì¹˜ ì‹œ **MatchError** ë°œìƒ

---

## í•¨ìˆ˜ì™€ íŒ¨í„´ ë§¤ì¹­

### ë‹¤ì¤‘ ì ˆ í•¨ìˆ˜ (Multiclause Functions)

* ê°™ì€ ì´ë¦„ì˜ í•¨ìˆ˜ë¥¼ ì—¬ëŸ¬ ì ˆë¡œ ì •ì˜ ê°€ëŠ¥.
* ê° ì ˆì€ ì…ë ¥ íŒ¨í„´ì— ë”°ë¼ ë‹¤ë¥´ê²Œ ì‘ë™.

```elixir
defmodule Geometry do
  def area({:rectangle, a, b}), do: a * b
  def area({:square, a}), do: a * a
  def area({:circle, r}), do: 3.14 * r * r
  def area(unknown), do: {:error, {:unknown_shape, unknown}}
end
```

* ìœ„ì—ì„œë¶€í„° ìˆœì„œëŒ€ë¡œ ë§¤ì¹­.
* ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ **FunctionClauseError** ë°œìƒ.
* ë§ˆì§€ë§‰ ì ˆì€ ê¸°ë³¸(fallback) ì—­í•  ìˆ˜í–‰.

---

### ê°€ë“œ (Guards)

* `when` ì ˆì„ ì´ìš©í•´ íŒ¨í„´ ë§¤ì¹­ì„ ë³´ê°•:

  ```elixir
  defmodule TestNum do
    def test(x) when is_number(x) and x < 0, do: :negative
    def test(0), do: :zero
    def test(x) when is_number(x) and x > 0, do: :positive
  end
  ```
* í—ˆìš©ëœ ì—°ì‚°ì: `==`, `<`, `>`, `and`, `or`, `not`, `is_*` ë“±
* guard ë‚´ë¶€ ì˜¤ë¥˜ëŠ” ë¬´ì‹œë˜ê³  falseë¡œ í‰ê°€ë¨.

---

### ë‹¤ì¤‘ ì ˆ ëŒë‹¤ (Multiclause Lambdas)

```elixir
test_num = fn
  x when x < 0 -> :negative
  0 -> :zero
  x when x > 0 -> :positive
end
```

ëŒë‹¤ë„ ì—¬ëŸ¬ ì ˆì„ ê°€ì§ˆ ìˆ˜ ìˆì–´ í•¨ìˆ˜í˜• ë¶„ê¸° ì‘ì„±ì´ ê°€ëŠ¥í•˜ë‹¤.

---

## ì¡°ê±´ë¬¸

### í•¨ìˆ˜ë¥¼ ì´ìš©í•œ ë¶„ê¸°

íŒ¨í„´ ë§¤ì¹­ ê¸°ë°˜ ì¡°ê±´:

```elixir
defmodule Polymorphic do
  def double(x) when is_number(x), do: 2 * x
  def double(x) when is_binary(x), do: x <> x
end
```

---

### ì „í†µì  ë¶„ê¸°ë¬¸ (if, unless, cond, case)

#### if / unless

```elixir
if a > b, do: a, else: b
unless result == :error, do: notify()
```

* `false`ì™€ `nil`ë§Œ ê±°ì§“ìœ¼ë¡œ ê°„ì£¼.

#### cond

```elixir
cond do
  x < 0 -> :negative
  x == 0 -> :zero
  true -> :positive
end
```

#### case

```elixir
case File.read("config") do
  {:ok, contents} -> IO.puts(contents)
  {:error, reason} -> IO.puts("Error: #{reason}")
  _ -> :unknown
end
```

* íŒ¨í„´ ë§¤ì¹­ ê¸°ë°˜ ë¶„ê¸°
* `_`ëŠ” ê¸°ë³¸ì ˆ(default)

---

### with í‘œí˜„ì‹

* ì—¬ëŸ¬ ë§¤ì¹­ì„ ì—°ì‡„ì ìœ¼ë¡œ ìˆ˜í–‰:

  ```elixir
  with {:ok, login} <- {:ok, "alice"},
       {:ok, email} <- {:ok, "mail@example.com"} do
    %{login: login, email: email}
  end
  ```
* ì‹¤íŒ¨í•œ ë§¤ì¹­ì´ ë‚˜ì˜¤ë©´ ì¦‰ì‹œ ë°˜í™˜.
* ì—°ì†ì ì¸ ê²€ì¦ íŒŒì´í”„ë¼ì¸ì— ìœ ìš©:

  ```elixir
  with {:ok, user} <- find_user(),
       {:ok, token} <- create_token(user),
       {:ok, resp} <- send_email(user, token) do
    {:ok, resp}
  end
  ```

---

## ë°˜ë³µê³¼ ìˆœíšŒ

### ì¬ê·€ë¥¼ ì´ìš©í•œ ë°˜ë³µ

```elixir
defmodule NaturalNums do
  def print(1), do: IO.puts(1)
  def print(n), do: print(n-1); IO.puts(n)
end
```

* `n=1` â†’ ì¢…ë£Œ
* ë‚˜ë¨¸ì§€ëŠ” `print(n-1)` í˜¸ì¶œë¡œ ë°˜ë³µ ìˆ˜í–‰

---

### ê¼¬ë¦¬ ì¬ê·€ (Tail Recursion)

* í•¨ìˆ˜ì˜ ë§ˆì§€ë§‰ ë™ì‘ì´ ìê¸° ìì‹  í˜¸ì¶œì´ë©´ **ìŠ¤íƒì„ ìƒˆë¡œ ìŒ“ì§€ ì•ŠëŠ”ë‹¤**.
* ë©”ëª¨ë¦¬ íš¨ìœ¨ì  ë£¨í”„ ê°€ëŠ¥.

```elixir
defmodule ListHelper do
  def sum(list), do: do_sum(0, list)
  defp do_sum(acc, []), do: acc
  defp do_sum(acc, [h | t]), do: do_sum(acc + h, t)
end
```

---

### ê³ ì°¨ í•¨ìˆ˜ (Higher-Order Functions)

#### Enum.each

```elixir
Enum.each([1,2,3], fn x -> IO.puts(x) end)
```

#### Enum.map

```elixir
Enum.map([1,2,3], &(&1 * 2))
```

#### Enum.filter

```elixir
Enum.filter([1,2,3], &(rem(&1,2)==1))
```

#### Enum.reduce

```elixir
Enum.reduce([1,2,3], 0, fn x, acc -> acc + x end)
```

* ë‹¤ì¤‘ ì ˆ ëŒë‹¤ë¡œ ì¡°ê±´ ë¶„ê¸° ê°€ëŠ¥:

  ```elixir
  fn
    n, acc when is_number(n) -> acc + n
    _, acc -> acc
  end
  ```

---

### ë‚´í¬ (Comprehensions)

ê°„ê²°í•œ ë°˜ë³µ/ë³€í™˜ í‘œí˜„:

```elixir
for x <- 1..3, do: x * x
# [1,4,9]
```

* ë‹¤ì¤‘ ë°˜ë³µ:

  ```elixir
  for x <- 1..3, y <- 1..3, do: {x,y,x*y}
  ```
* `into:` ì˜µì…˜ìœ¼ë¡œ ë§µì´ë‚˜ ë¦¬ìŠ¤íŠ¸ë¡œ ìˆ˜ì§‘ ê°€ëŠ¥.

---

### ìŠ¤íŠ¸ë¦¼ (Streams)

* **ì§€ì—° í‰ê°€(lazy evaluation)** ê¸°ë°˜ì˜ enumerable
* ì‹¤ì œ ë°ì´í„°ëŠ” í•„ìš”í•  ë•Œë§Œ ê³„ì‚°ë¨

```elixir
[1,2,3]
|> Stream.map(&(&1 * 2))
|> Enum.take(2)
```

* íŒŒì¼ ì²˜ë¦¬ ì˜ˆì‹œ:

  ```elixir
  File.stream!("data.txt")
  |> Stream.map(&String.trim_trailing(&1, "\n"))
  |> Enum.filter(&(String.length(&1) > 80))
  ```

  â†’ í•œ ì¤„ì”© ì½ìœ¼ë©° ì²˜ë¦¬ (ëŒ€ìš©ëŸ‰ ë°ì´í„°ì— íš¨ìœ¨ì )

* ë¬´í•œ ìŠ¤íŠ¸ë¦¼ ìƒì„±:

  ```elixir
  natural_numbers = Stream.iterate(1, &(&1 + 1))
  Enum.take(natural_numbers, 10)
  ```

---

## í•µì‹¬ ìš”ì•½

* `=`ëŠ” **í• ë‹¹ì´ ì•„ë‹Œ ë§¤ì¹­** â€” êµ¬ì¡°ë¥¼ ê²€ì‚¬í•˜ê³  ë°”ì¸ë”©í•¨
* **ë‹¤ì¤‘ ì ˆ í•¨ìˆ˜**ì™€ **ê°€ë“œ**ë¡œ ì¡°ê±´ ë¶„ê¸° í‘œí˜„
* **ì¬ê·€ì™€ ê¼¬ë¦¬ í˜¸ì¶œ**ì´ ë£¨í”„ ì—­í• ì„ ìˆ˜í–‰
* **with í‘œí˜„ì‹**ìœ¼ë¡œ ë‹¤ë‹¨ê³„ ê²€ì¦ì„ ê°„ê²°íˆ í‘œí˜„
* **Enum / Stream / Comprehension**ìœ¼ë¡œ ë°˜ë³µê³¼ ë³€í™˜ì„ ì„ ì–¸ì ìœ¼ë¡œ ì²˜ë¦¬
* í•¨ìˆ˜í˜• ì œì–´ íë¦„ì˜ í•µì‹¬ì€ **ë¶ˆë³€ì„±, ëª…í™•ì„±, ì„ ì–¸ì„±**

