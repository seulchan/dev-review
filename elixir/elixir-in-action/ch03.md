# Chapter 3. 제어 흐름 (Control Flow)

## 📑 목차

1. [패턴 매칭 (Pattern Matching)](#패턴-매칭-pattern-matching)

   * [매치 연산자](#매치-연산자)
   * [튜플 매칭](#튜플-매칭)
   * [상수 매칭](#상수-매칭)
   * [변수와 핀 연산자](#변수와-핀-연산자)
   * [리스트 매칭](#리스트-매칭)
   * [맵 매칭](#맵-매칭)
   * [바이너리 매칭](#바이너리-매칭)
   * [복합 매칭](#복합-매칭)
   * [패턴 매칭의 일반 동작](#패턴-매칭의-일반-동작)
2. [함수와 패턴 매칭](#함수와-패턴-매칭)

   * [다중 절 함수 (Multiclause Functions)](#다중-절-함수-multiclause-functions)
   * [가드 (Guards)](#가드-guards)
   * [다중 절 람다 (Multiclause Lambdas)](#다중-절-람다-multiclause-lambdas)
3. [조건문](#조건문)

   * [함수를 이용한 분기](#함수를-이용한-분기)
   * [전통적 분기문 (if, unless, cond, case)](#전통적-분기문-if-unless-cond-case)
   * [with 표현식](#with-표현식)
4. [반복과 순회](#반복과-순회)

   * [재귀를 이용한 반복](#재귀를-이용한-반복)
   * [꼬리 재귀 (Tail Recursion)](#꼬리-재귀-tail-recursion)
   * [고차 함수 (Higher-Order Functions)](#고차-함수-higher-order-functions)
   * [내포 (Comprehensions)](#내포-comprehensions)
   * [스트림 (Streams)](#스트림-streams)
5. [핵심 요약](#핵심-요약)

---

## 패턴 매칭 (Pattern Matching)

### 매치 연산자

* `=`는 **할당(assign)** 이 아닌 **매칭(match)** 연산자이다.

* 왼쪽은 **패턴**, 오른쪽은 **값(term)**

  ```elixir
  {name, age} = {"Bob", 25}
  ```

  → `name = "Bob"`, `age = 25`

* 불일치 시 오류 발생:

  ```elixir
  {name, age} = "can't match"
  # ** (MatchError)
  ```

* 반환값은 항상 **오른쪽 값**이다.

---

### 튜플 매칭

```elixir
{name, age} = {"Alice", 30}
```

* 오른쪽 값이 `{}` 형태일 때만 매칭된다.
* 구조가 다르면 **MatchError** 발생.

---

### 상수 매칭

* 왼쪽에 상수도 가능:

  ```elixir
  1 = 1  # OK
  1 = 2  # 오류
  ```

* 예시: 파일 읽기 시 패턴 사용

  ```elixir
  {:ok, contents} = File.read("config.txt")
  ```

  → 실패 시 `{:error, reason}`으로 매칭 실패.

---

### 변수와 핀 연산자

* `_` : 아무 값이나 매칭하지만 바인딩하지 않음

  ```elixir
  {_, time} = :calendar.local_time()
  ```

* `_date` : 변수명 앞에 `_`가 있으면 “무시” 변수로 간주.

* **핀 연산자 `^`** : 이미 바인딩된 값과 비교

  ```elixir
  expected = "Bob"
  {^expected, _} = {"Bob", 25}  # OK
  {^expected, _} = {"Alice", 30} # 오류
  ```

---

### 리스트 매칭

```elixir
[first, second, third] = [1, 2, 3]
[first, _] = [1, 2]
[^first, _] = [1, 3]  # 매칭 실패
```

---

### 맵 매칭

* 부분 매칭 가능:

  ```elixir
  %{name: name, age: age} = %{name: "Bob", age: 25}
  %{age: age} = %{name: "Bob", age: 25}
  ```
* 존재 하지 않는 키 포함 시 실패:

  ```elixir
  %{age: age, job: job} = %{name: "Bob", age: 25}
  # MatchError
  ```

---

### 바이너리 매칭

```elixir
<<a, b, c>> = <<1, 2, 3>>
<<first, rest::binary>> = <<1, 2, 3>>
<<hi::4, lo::4>> = <<155>> # hi=9, lo=11
```

* 문자열도 이진(binary)으로 다룰 수 있음:

  ```elixir
  "ping " <> url = "ping www.example.com"
  url # "www.example.com"
  ```

---

### 복합 매칭

패턴을 중첩 가능:

```elixir
[_, {name, _}, _] = [{"Bob", 25}, {"Alice", 30}, {"John", 35}]
```

---

### 패턴 매칭의 일반 동작

1. 오른쪽 표현식을 평가
2. 왼쪽 패턴과 비교
3. 일치 시 변수 바인딩
4. 결과는 오른쪽 값
5. 불일치 시 **MatchError** 발생

---

## 함수와 패턴 매칭

### 다중 절 함수 (Multiclause Functions)

* 같은 이름의 함수를 여러 절로 정의 가능.
* 각 절은 입력 패턴에 따라 다르게 작동.

```elixir
defmodule Geometry do
  def area({:rectangle, a, b}), do: a * b
  def area({:square, a}), do: a * a
  def area({:circle, r}), do: 3.14 * r * r
  def area(unknown), do: {:error, {:unknown_shape, unknown}}
end
```

* 위에서부터 순서대로 매칭.
* 매칭 실패 시 **FunctionClauseError** 발생.
* 마지막 절은 기본(fallback) 역할 수행.

---

### 가드 (Guards)

* `when` 절을 이용해 패턴 매칭을 보강:

  ```elixir
  defmodule TestNum do
    def test(x) when is_number(x) and x < 0, do: :negative
    def test(0), do: :zero
    def test(x) when is_number(x) and x > 0, do: :positive
  end
  ```
* 허용된 연산자: `==`, `<`, `>`, `and`, `or`, `not`, `is_*` 등
* guard 내부 오류는 무시되고 false로 평가됨.

---

### 다중 절 람다 (Multiclause Lambdas)

```elixir
test_num = fn
  x when x < 0 -> :negative
  0 -> :zero
  x when x > 0 -> :positive
end
```

람다도 여러 절을 가질 수 있어 함수형 분기 작성이 가능하다.

---

## 조건문

### 함수를 이용한 분기

패턴 매칭 기반 조건:

```elixir
defmodule Polymorphic do
  def double(x) when is_number(x), do: 2 * x
  def double(x) when is_binary(x), do: x <> x
end
```

---

### 전통적 분기문 (if, unless, cond, case)

#### if / unless

```elixir
if a > b, do: a, else: b
unless result == :error, do: notify()
```

* `false`와 `nil`만 거짓으로 간주.

#### cond

```elixir
cond do
  x < 0 -> :negative
  x == 0 -> :zero
  true -> :positive
end
```

#### case

```elixir
case File.read("config") do
  {:ok, contents} -> IO.puts(contents)
  {:error, reason} -> IO.puts("Error: #{reason}")
  _ -> :unknown
end
```

* 패턴 매칭 기반 분기
* `_`는 기본절(default)

---

### with 표현식

* 여러 매칭을 연쇄적으로 수행:

  ```elixir
  with {:ok, login} <- {:ok, "alice"},
       {:ok, email} <- {:ok, "mail@example.com"} do
    %{login: login, email: email}
  end
  ```
* 실패한 매칭이 나오면 즉시 반환.
* 연속적인 검증 파이프라인에 유용:

  ```elixir
  with {:ok, user} <- find_user(),
       {:ok, token} <- create_token(user),
       {:ok, resp} <- send_email(user, token) do
    {:ok, resp}
  end
  ```

---

## 반복과 순회

### 재귀를 이용한 반복

```elixir
defmodule NaturalNums do
  def print(1), do: IO.puts(1)
  def print(n), do: print(n-1); IO.puts(n)
end
```

* `n=1` → 종료
* 나머지는 `print(n-1)` 호출로 반복 수행

---

### 꼬리 재귀 (Tail Recursion)

* 함수의 마지막 동작이 자기 자신 호출이면 **스택을 새로 쌓지 않는다**.
* 메모리 효율적 루프 가능.

```elixir
defmodule ListHelper do
  def sum(list), do: do_sum(0, list)
  defp do_sum(acc, []), do: acc
  defp do_sum(acc, [h | t]), do: do_sum(acc + h, t)
end
```

---

### 고차 함수 (Higher-Order Functions)

#### Enum.each

```elixir
Enum.each([1,2,3], fn x -> IO.puts(x) end)
```

#### Enum.map

```elixir
Enum.map([1,2,3], &(&1 * 2))
```

#### Enum.filter

```elixir
Enum.filter([1,2,3], &(rem(&1,2)==1))
```

#### Enum.reduce

```elixir
Enum.reduce([1,2,3], 0, fn x, acc -> acc + x end)
```

* 다중 절 람다로 조건 분기 가능:

  ```elixir
  fn
    n, acc when is_number(n) -> acc + n
    _, acc -> acc
  end
  ```

---

### 내포 (Comprehensions)

간결한 반복/변환 표현:

```elixir
for x <- 1..3, do: x * x
# [1,4,9]
```

* 다중 반복:

  ```elixir
  for x <- 1..3, y <- 1..3, do: {x,y,x*y}
  ```
* `into:` 옵션으로 맵이나 리스트로 수집 가능.

---

### 스트림 (Streams)

* **지연 평가(lazy evaluation)** 기반의 enumerable
* 실제 데이터는 필요할 때만 계산됨

```elixir
[1,2,3]
|> Stream.map(&(&1 * 2))
|> Enum.take(2)
```

* 파일 처리 예시:

  ```elixir
  File.stream!("data.txt")
  |> Stream.map(&String.trim_trailing(&1, "\n"))
  |> Enum.filter(&(String.length(&1) > 80))
  ```

  → 한 줄씩 읽으며 처리 (대용량 데이터에 효율적)

* 무한 스트림 생성:

  ```elixir
  natural_numbers = Stream.iterate(1, &(&1 + 1))
  Enum.take(natural_numbers, 10)
  ```

---

## 핵심 요약

* `=`는 **할당이 아닌 매칭** — 구조를 검사하고 바인딩함
* **다중 절 함수**와 **가드**로 조건 분기 표현
* **재귀와 꼬리 호출**이 루프 역할을 수행
* **with 표현식**으로 다단계 검증을 간결히 표현
* **Enum / Stream / Comprehension**으로 반복과 변환을 선언적으로 처리
* 함수형 제어 흐름의 핵심은 **불변성, 명확성, 선언성**

