# Chapter 3. Control flow

## üìë Table of Contents

1. [Pattern Matching](#pattern-matching)

   * [Match Operator](#the-match-operator)
   * [Tuples](#matching-tuples)
   * [Constants](#matching-constants)
   * [Variables and the Pin Operator](#variables-in-patterns)
   * [Lists](#matching-lists)
   * [Maps](#matching-maps)
   * [Binaries](#matching-bitstrings-and-binaries)
   * [Compound Matches](#compound-matches)
   * [General Behavior](#general-behavior)
2. [Pattern Matching in Functions](#matching-with-functions)

   * [Multiclause Functions](#multiclause-functions)
   * [Guards](#guards)
   * [Multiclause Lambdas](#multiclause-lambdas)
3. [Conditionals](#conditionals)

   * [Multiclause Functions as Branches](#branching-with-multiclause-functions)
   * [Classical Branching: if, unless, cond, case](#classical-branching-expressions)
   * [The with Expression](#the-with-expression)
4. [Loops and Iterations](#loops-and-iterations)

   * [Recursion](#iterating-with-recursion)
   * [Tail Recursion](#tail-function-calls)
   * [Higher-Order Functions](#higher-order-functions)
   * [Comprehensions](#comprehensions)
   * [Streams](#streams)
5. [Key Takeaways](#key-takeaways)

---

## Pattern Matching

### The Match Operator

* The `=` operator is **not assignment** but a **match operator**.

* Left side = pattern; right side = term (value/expression).

* Example:

  ```elixir
  {name, age} = {"Bob", 25}
  ```

  ‚Üí `name = "Bob"`, `age = 25`.

* Mismatch raises an error:

  ```elixir
  {name, age} = "can't match"
  # ** (MatchError)
  ```

* Returns the **right-hand value**.

---

### Matching Constants

* Constants can appear on the left:

  ```elixir
  1 = 1  # OK
  1 = 2  # ** (MatchError)
  ```

* Common idiom:

  ```elixir
  {:ok, contents} = File.read("config.txt")
  ```

  If the result is `{:error, reason}`, match fails ‚Üí exception raised.

---

### Variables in Patterns

* Variables always match and bind to the right-hand term.

* `_` (underscore) matches any value but doesn‚Äôt bind.

  ```elixir
  {_, time} = :calendar.local_time()
  ```

* Variables prefixed with `_` (e.g., `_date`) behave as ‚Äúignored‚Äù values.

* **Pin operator `^`**: match against existing variable value.

  ```elixir
  expected = "Bob"
  {^expected, _} = {"Bob", 25}  # OK
  {^expected, _} = {"Alice", 30} # MatchError
  ```

---

### Matching Lists

```elixir
[first, second, third] = [1, 2, 3]
[first, _] = [1, 2]   # ignores second
[^first, _] = [1, 3]  # match fails if mismatch
```

---

### Matching Maps

* Partial map matches allowed:

  ```elixir
  %{name: name, age: age} = %{name: "Bob", age: 25}
  %{age: age} = %{name: "Bob", age: 25}
  ```

* Missing key ‚Üí MatchError.

---

### Matching Bitstrings and Binaries

```elixir
<<a, b, c>> = <<1, 2, 3>>
<<first, rest::binary>> = <<1, 2, 3>>
<<hi::4, lo::4>> = <<155>> # splits 8 bits: hi=9, lo=11
```

* For strings:

  ```elixir
  "ping " <> url = "ping www.example.com"
  url # "www.example.com"
  ```

---

### Compound Matches

Patterns can nest:

```elixir
[_, {name, _}, _] = [{"Bob", 25}, {"Alice", 30}, {"John", 35}]
```

---

### General Behavior

* A match:

  1. Evaluates right side.
  2. Compares with left-side pattern.
  3. Binds variables if successful.
* Result = right-hand term.
* Failed matches raise **MatchError**.

---

## Matching with Functions

### Multiclause Functions

Define functions with multiple clauses for **pattern-dependent behavior**:

```elixir
defmodule Geometry do
  def area({:rectangle, a, b}), do: a * b
  def area({:square, a}), do: a * a
  def area({:circle, r}), do: 3.14 * r * r
  def area(unknown), do: {:error, {:unknown_shape, unknown}}
end
```

* Clauses are evaluated in order.
* If no clause matches ‚Üí **FunctionClauseError**.
* A default (variable-only) clause catches unmatched input.

---

### Guards

Add conditions using `when`:

```elixir
defmodule TestNum do
  def test(x) when is_number(x) and x < 0, do: :negative
  def test(0), do: :zero
  def test(x) when is_number(x) and x > 0, do: :positive
end
```

* Guards refine matches beyond pattern shape.
* Allowed operators: `==`, `>`, `<`, arithmetic ops, and `is_*` type-checks.
* Errors inside guards return `false` silently.

---

### Multiclause Lambdas

Anonymous functions (`fn`) can also have multiple clauses:

```elixir
test_num = fn
  x when x < 0 -> :negative
  0 -> :zero
  x when x > 0 -> :positive
end
```

Compact but powerful ‚Äî like pattern-matched lambdas in other FP languages.

---

## Conditionals

### Branching with Multiclause Functions

Example:

```elixir
defmodule Polymorphic do
  def double(x) when is_number(x), do: 2 * x
  def double(x) when is_binary(x), do: x <> x
end
```

Pattern matching makes conditionals declarative and polymorphic.

---

### Classical Branching Expressions

#### `if` and `unless`

```elixir
if condition, do: expr1, else: expr2
unless x == :error, do: handle_success()
```

* Truthy: everything except `false` and `nil`.
* Returns value of executed block.

#### `cond`

Like `if‚Äìelse-if` chains:

```elixir
cond do
  x < 0 -> :negative
  x == 0 -> :zero
  true -> :positive
end
```

#### `case`

Pattern-based branching:

```elixir
case File.read("config") do
  {:ok, contents} -> IO.puts(contents)
  {:error, reason} -> IO.puts("Error: #{reason}")
end
```

`_ ->` can be used as a default clause.

---

### The `with` Expression

Chains multiple matches, short-circuiting on failure:

```elixir
with {:ok, login} <- {:ok, "alice"},
     {:ok, email} <- {:ok, "mail@example.com"} do
  %{login: login, email: email}
end
```

If any match fails, returns the first unmatched term (e.g., `{:error, reason}`).

Useful for sequential validation pipelines:

```elixir
with {:ok, user} <- find_user(),
     {:ok, token} <- create_token(user),
     {:ok, resp} <- send_email(user, token) do
  {:ok, resp}
end
```

---

## Loops and Iterations

### Iterating with Recursion

```elixir
defmodule NaturalNums do
  def print(1), do: IO.puts(1)
  def print(n), do: print(n - 1); IO.puts(n)
end
```

Recursion replaces loops.
Base case ‚Üí recursion termination.

---

### Tail Function Calls

Tail recursion = no extra stack frame.

```elixir
defmodule ListHelper do
  def sum(list), do: do_sum(0, list)
  defp do_sum(acc, []), do: acc
  defp do_sum(acc, [h | t]), do: do_sum(acc + h, t)
end
```

Behaves like a loop ‚Üí efficient and memory-safe.

---

### Higher-Order Functions

Functions that accept or return other functions.

#### Enum.each

```elixir
Enum.each([1,2,3], fn x -> IO.puts(x) end)
```

#### Enum.map

```elixir
Enum.map([1,2,3], &(&1 * 2))
```

#### Enum.filter

```elixir
Enum.filter([1,2,3], &(rem(&1,2) == 1))
```

#### Enum.reduce

```elixir
Enum.reduce([1,2,3], 0, fn x, acc -> acc + x end)
```

* Multi-clause version:

  ```elixir
  fn
    n, acc when is_number(n) -> acc + n
    _, acc -> acc
  end
  ```

---

### Comprehensions

Elegant iteration and transformation:

```elixir
for x <- 1..3, do: x * x
# [1, 4, 9]

for x <- 1..3, y <- 1..3, into: %{}, do: {{x, y}, x*y}
# Multiplication table map
```

* Filters:

  ```elixir
  for x <- 1..9, y <- 1..9, x <= y, do: {x, y, x*y}
  ```

---

### Streams

Streams are **lazy enumerables** ‚Äî they build computation pipelines but execute only when needed.

```elixir
[1,2,3]
|> Stream.map(&(&1 * 2))
|> Enum.take(2)
```

‚Üí computes only the first two elements.

Efficient for large data, e.g. file processing:

```elixir
File.stream!("data.txt")
|> Stream.map(&String.trim_trailing(&1, "\n"))
|> Enum.filter(&(String.length(&1) > 80))
```

Only reads as many lines as necessary.

---

## Key Takeaways

* **Pattern matching** is central ‚Äî not assignment but *structural assertion*.
* **Multiclause functions** and **guards** replace imperative branching.
* **Recursion and tail calls** are Elixir‚Äôs way of looping.
* **with** allows elegant sequential error handling.
* **Higher-order functions** (`Enum.map`, `reduce`, etc.) express iteration declaratively.
* **Comprehensions** and **streams** offer elegant and lazy data transformation.
* Functional control flow emphasizes **clarity, immutability, and expressiveness**.
